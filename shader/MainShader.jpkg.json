{"additive_uvroll.fs.glsl":"\nprecision mediump float;\n\nvarying vec2 v_uv;\n\nuniform vec4 _TintColor;\nuniform sampler2D _MainTex;\n\nvoid main()\n{\n    gl_FragColor = 2.0 * _TintColor * texture2D(_MainTex, v_uv);\n}","additive_uvroll.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","additive_uvroll.vs.glsl":"\nprecision mediump float;  \n\n//坐标属性\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\n\nuniform vec4 _MainTex_ST;\n\nuniform float _UVSpeedX;\nuniform float _UVSpeedY;\nuniform float glstate_timer;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n    //输出uv\n    v_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw + vec2(_UVSpeedX,_UVSpeedY) * glstate_timer;\n\n    //计算投影坐标\n    gl_Position = glstate_matrix_mvp * position;\n}","alphablended_uvroll.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","asi.fs.glsl":"uniform lowp sampler2D _MainTex;  \nuniform lowp sampler2D _asm;\nuniform lowp sampler2D _streamlight;\nuniform lowp float _LightRate;\nuniform lowp vec4 _LightColor;\nuniform lowp float _emitpow;\nuniform lowp float _diffuse;\n//uniform highp float _Cutoff;\n\n\nvarying mediump vec2 _base_uv;\nvarying mediump vec2 _asm_uv;\nvarying mediump vec2 _light_uv;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//texture2DEtC1Mark\n\nvoid main() \n{\n    \n    lowp vec4 baseTex=texture2D(_MainTex,_base_uv);\n    if(baseTex.a<0.5)\n    {\n        discard;\n    }\n    lowp vec3 asi=texture2D(_asm,_asm_uv).rgb;\n    lowp vec3 d_color=baseTex.rgb*_diffuse;\n    lowp vec3 e_color=baseTex.rgb*_emitpow*asi.g;\n    lowp vec3 light = texture2D(_streamlight, _light_uv).rgb* _LightRate*_LightColor.xyz;\n    light = min(light,asi.b);\n    light = light*_LightRate*_LightColor.xyz;\n    lowp vec4 emission=vec4(d_color+e_color+light,1.0);\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n\n    gl_FragData[0] = emission;\n}\n\n","asi.shader.json":"{\n    \"layer\": \"geometry\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"asi\",\n                \"fs\": \"asi\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"asi\",\n                \"fs\": \"asi\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"asi\",\n                \"fs\": \"asi\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"asi\",\n                \"fs\": \"asi\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","asi.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\nuniform mediump vec4 _asm_ST;\nuniform mediump vec4 _streamlight_ST;\nuniform lowp float _speedu;\nuniform lowp float _speedv;\nuniform lowp float glstate_timer;\n\nvarying mediump vec2 _base_uv;\nvarying mediump vec2 _asm_uv;\nvarying mediump vec2 _light_uv;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\nvoid main()\n{\n\thighp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\t_asm_uv = _glesMultiTexCoord0.xy * _asm_ST.xy + _asm_ST.zw;\n\tlowp vec2 _speed;\n    _speed = vec2(_speedu,_speedv);\n    _light_uv = (_glesMultiTexCoord0.xy * _streamlight_ST.xy + _streamlight_ST.zw)  + _speed * glstate_timer;\n\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\tgl_Position = position;\n}\n\n","barrel_blur.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D _MainTex;\nuniform float _Power;\nvarying highp vec2 xlv_TEXCOORD0;\n\nconst int num_iter = 20;\n\n//texture2DEtC1Mark\n\nvec2 barrelDistortion(vec2 coord, float amt)\n{\n    vec2 cc = coord - 0.5;\n    float dist = dot(cc, cc);\n    return coord + cc * dist * amt;\n}\n\nfloat linterp(float t)\n{\n    return clamp(1.0 - abs(2.0 * t - 1.0), 0.0, 1.0);\n}\n\nfloat remap (float t, float a, float b)\n{\n    return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\nvec3 spectrum_offset(float t)\n{\n    vec3 ret;\n    float lo = step(t, 0.5);\n    float hi = 1.0 - lo;\n    float w = linterp(remap(t, 1.0 / 6.0, 5.0 / 6.0));\n    ret = vec3(lo, 1.0, hi) * vec3(1.0 - w, w, 1.0 - w);\n    return pow(ret, vec3(1.0 / 2.2));\n}\n\nvoid main()\n{\n    vec2 uv = xlv_TEXCOORD0.xy;\n    vec3 sumcol = vec3(0.0);\n    vec3 sumw = vec3(0.0);\n    float reci_num_iter_f = 1.0 / float(num_iter);\n    for (int i = 0; i < num_iter; i++)\n    {\n        float t = float(i) * reci_num_iter_f;\n        vec3 w = spectrum_offset(t);\n        sumw += w;\n        sumcol += w * texture2D(_MainTex, barrelDistortion(uv, _Power * t)).rgb;\n    }\n\n    gl_FragData[0] = vec4(sumcol.rgb / sumw, 1.0);\n}","barrel_blur.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Power('Power',Float)=0.5\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"barrel_blur\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"barrel_blur\"\n            }\n        ]\n    }\n}","blendnotest.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;   \n\nuniform lowp vec4 _Main_Color;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _Main_Tex_ST;\n\n\nvarying lowp vec4 xlv_COLOR;\nvarying mediump vec2 xlv_TEXCOORD0;                \nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz,1.0);\n    xlv_COLOR = vec4(1.0,1.0,1.0,1.0);\n\txlv_TEXCOORD0 =_glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n                \n    gl_Position = (glstate_matrix_mvp *tmpvar_1);  \n}","blend_notest.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t    \"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blend\",\n            \"showface\": \"ccw\",\n            \"zwrite\": \"off\",\n            \"ztest\":\"off\",\n            \"vs\": \"blendnotest\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","bloom.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D       _MainTex;//清晰图\nuniform sampler2D       _BlurTex;//模糊高光的图\nuniform highp vec4      _MainTex_TexelSize;\n\nuniform highp float     _bloomIntensity;\n// 强度 - 附加光（影响到该特效的光源）的全局光强\nuniform highp vec4     _blurSpread;\n// 模糊扩散 - Frag down sample 的偏移距离\nuniform highp float     _bloomThreshold;\n// 阈值 - 图像中亮度高于该阈值的区域将产生泛光效果\n\nvarying highp vec2      xlv_TEXCOORD0;   // 每个片元的纹素坐标\n\n#define INTENSITY       _bloomIntensity\n#define THRESHOLD       _bloomThreshold\n#define BLUR_SPREAD     vec2(_blurSpread.xy * _MainTex_TexelSize.xy)\n\n#define tex(t, uv)      texture2D((t), (uv))\n\n//texture2DEtC1Mark\n\nfloat luminance(vec3 rgb) {\n    const vec3 w = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, w);\n}\n// Blur spread 扩撒\nvec4 fragDownsample(sampler2D image, vec2 uv) {\n    vec2 uv2[4];\n    uv2[0] = uv + _MainTex_TexelSize.xy * vec2(1.5, 1.5);\n    uv2[1] = uv + _MainTex_TexelSize.xy * vec2(-1.5, 1.5);\n    uv2[2] = uv + _MainTex_TexelSize.xy * vec2(-1.5, -1.5);\n    uv2[3] = uv + _MainTex_TexelSize.xy * vec2(1.5, -1.5);\n    vec4 color;\n    color += texture2D(image, uv2[0]);\n    color += texture2D(image, uv2[1]);\n    color += texture2D(image, uv2[2]);\n    color += texture2D(image, uv2[3]);\n    return max(color/4.0 - THRESHOLD, vec4(0.0)) * INTENSITY;\n}\nvec4 fastBlur(sampler2D image, vec2 uv, vec2 netFilterWidth) {\n\n    vec4 blur = vec4(0.0);\n    vec2 _offset[7];\n    vec4 curve[7];\n    curve[0] = vec4(0.0205, 0.0205, 0.0205, 0.0);\n    curve[1] = vec4(0.0855, 0.0855, 0.0855, 0.0);\n    curve[2] = vec4(0.232, 0.232, 0.232, 0.0);\n    curve[3] = vec4(0.324, 0.324, 0.324, 1.0);\n    curve[4] = vec4(0.232, 0.232, 0.232, 0.0);\n    curve[5] = vec4(0.0855, 0.0855, 0.0855, 0.0);\n    curve[6] = vec4(0.0205, 0.0205, 0.0205, 0.0);\n    // horizontal or vertical blur, defined by netFilterWidth vector\n    _offset[0] = uv + netFilterWidth * 3.0;\n    _offset[1] = uv + netFilterWidth * 2.0;\n    _offset[2] = uv + netFilterWidth;\n    _offset[3] = uv;\n    _offset[4] = uv - netFilterWidth;\n    _offset[5] = uv - netFilterWidth * 2.0;\n    _offset[6] = uv - netFilterWidth * 3.0;\n    for(int l = 0; l < 7; l++) {\n        blur += tex(image, _offset[l]) * curve[l];\n    }\n\n    return blur;\n}\n\nvoid main () {\n    if(BLUR_SPREAD.x == 0.0 && BLUR_SPREAD.y == 0.0) {    // 不泛光, 只过滤\n        gl_FragColor = fragDownsample(_MainTex, xlv_TEXCOORD0);\n    } else if(THRESHOLD == 1.0){    // 不过滤, 只泛光\n        gl_FragColor = fastBlur(_MainTex, xlv_TEXCOORD0, BLUR_SPREAD);\n    } else {    // Final Composition\n        vec4 originColor = texture2D(_MainTex, xlv_TEXCOORD0);\n        originColor = vec4(originColor.rgb * INTENSITY, originColor.a);\n        vec4 bloomColor = texture2D(_BlurTex, xlv_TEXCOORD0);\n        gl_FragColor = originColor + bloomColor;\n    }\n\n    // vec4 c = texture2D(_MainTex, xlv_TEXCOORD0);\n    // vec4 cur_color;\n    // cur_color = fastBlur(_MainTex, xlv_TEXCOORD0,BLUR_SPREAD);\n    //\n    // c = vec4(c.rgb * INTENSITY, c.a) / 2.0;\n    // gl_FragColor = c;\n}\n","bloom.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_bloomFactor('bloomFactor',Range(0.0,1.0)) = 2.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"bloom\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"bloom\"\n            }\n        ]\n    }\n}","blur.fs.glsl":"uniform sampler2D _MainTex;\nuniform lowp float _BlurGap; //卷积每层间隔单位\nuniform highp vec4 _MainTex_TexelSize;\nvarying highp vec2 xlv_TEXCOORD0;\n//texture2DEtC1Mark\n\nvoid main() \n{\n\tlowp float offset_x = _MainTex_TexelSize.x * _BlurGap;\n\tlowp float offset_y = _MainTex_TexelSize.y * _BlurGap;\n    highp vec4 sample0,sample1,sample2,sample3;\n\tsample0=texture2D(_MainTex,vec2(xlv_TEXCOORD0.x-offset_x,xlv_TEXCOORD0.y-offset_y));\n\tsample1=texture2D(_MainTex,vec2(xlv_TEXCOORD0.x+offset_x,xlv_TEXCOORD0.y-offset_y));\n\tsample2=texture2D(_MainTex,vec2(xlv_TEXCOORD0.x+offset_x,xlv_TEXCOORD0.y+offset_y));\n\tsample3=texture2D(_MainTex,vec2(xlv_TEXCOORD0.x-offset_x,xlv_TEXCOORD0.y+offset_y));\n\thighp vec4 color=(sample0+sample1+sample2+sample3) / 4.0;\n    gl_FragData[0] = color;\n}","blur.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_BlurGap('_BlurGap',float)=1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"blur\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"blur\"\n            }\n        ]\n    }\n}","contort.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nconst float PI = 3.14159265;\nuniform sampler2D _MainTex;\nuniform float _UD;\nuniform float _UR;\nvarying highp vec2 xlv_TEXCOORD0;\n//texture2DEtC1Mark\n\nvoid main()\n{\n    ivec2 ires = ivec2(1024, 1024);\n    float Res = float(ires.s);\n\n    vec2 st = xlv_TEXCOORD0;\n    float Radius = Res * _UR;\n    vec2 xy = Res * st;\n\n    vec2 dxy = xy - vec2(Res / 2.0, Res / 2.0);\n    float r = length(dxy);\n    float beta = atan(dxy.y, dxy.x) + radians(_UD) * 2.0 * (Radius - r) / Radius;\n\n    vec2 xy1 = xy;\n    if (r <= Radius)\n    {\n        xy1 = Res / 2.0 + r * vec2(cos(beta), sin(beta));\n    }\n    st = xy1 / Res;\n\n    vec3 irgb = texture2D(_MainTex, st).rgb;\n\n    gl_FragData[0] = vec4(irgb, 1.0);\n}","contort.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_UD('UD',float)=90\",\n        \"_UR('UR',float)=0.2\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"contort\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"contort\"\n            }\n        ]\n    }\n}","demo_gpu_ins.fs.glsl":"varying lowp vec4 xlv_COLOR;\n\nvoid main()\n{\n    gl_FragData[0] = xlv_COLOR;\n}","demo_gpu_ins.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesColor;\n\n#ifdef INSTANCE\nattribute vec4 a_particle_color;\nattribute highp vec4 instance_offset_matrix_0;\nattribute highp vec4 instance_offset_matrix_1;\nattribute highp vec4 instance_offset_matrix_2;\nattribute highp vec4 instance_offset_matrix_3;\n#else\nuniform vec4 a_particle_color;\n#endif\n\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    tmpvar_1.w = 1.0;\n    #ifdef INSTANCE\n        highp mat4 instance_offset_matrix = mat4(instance_offset_matrix_0,instance_offset_matrix_1,instance_offset_matrix_2,instance_offset_matrix_3);\n        tmpvar_1 = instance_offset_matrix * tmpvar_1;\n    // #else\n    //     xlv_COLOR = _glesColor - a_particle_color;\n    #endif\n\n    xlv_COLOR = a_particle_color;\n\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}","demo_gpu_instancing.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n     \n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"demo_gpu_ins\",\n                \"fs\": \"demo_gpu_ins\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"demo_gpu_ins\",\n                \"fs\": \"demo_gpu_ins\"\n            }\n        ],\n        \"instance\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"demo_gpu_ins\",\n                \"fs\": \"demo_gpu_ins\"\n            }\n        ],\n        \"instance_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"demo_gpu_ins\",\n                \"fs\": \"demo_gpu_ins\"\n            }\n        ]\n    }\n}","diffuse.fs.glsl":"precision lowp float;\nuniform lowp sampler2D _MainTex;\nuniform lowp vec4 _MainColor;\nuniform lowp float _AlphaCut;\nvarying mediump vec2 xlv_TEXCOORD0;\n\n//light\nlowp vec4 xlv_COLOR = vec4(0.0,0.0,0.0,1.0); \nbool hasLight = false;\nlowp vec3 fixedAmbient = vec3(0.6,0.6,0.6);\nuniform lowp float glstate_lightcount;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp vec4 glstate_vec4_lightcolors[8];\nuniform lowp float glstate_float_lightrange[8];\nuniform lowp float glstate_float_lightintensity[8];\n\nvarying lowp vec3 v_N;\nvarying lowp vec3 v_Mpos;\n\n//texture2DEtC1Mark\n\n#ifdef LIGHTMAP\nuniform lowp float glstate_lightmapRGBAF16;\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot,lowp float range )\n{\n    lowp vec3 v3 = lightPos.xyz - worldpos;\n    lowp float len = length(v3);\n    len = len > range ? range : len;\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(v3); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0) * pow(1.0 - len/range,2.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n    return diffuse;\n}\n\nvoid calcCOLOR(){\n    int c =int(glstate_lightcount);\n\tif(c>0){\n        hasLight = true;\n        lowp float diff=0.0;\n\t\t//calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tif(i>=c)break;\n\t\t\t//diff += calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n\t\t\tdiff = calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n            xlv_COLOR += glstate_float_lightintensity[i] * glstate_vec4_lightcolors[i] * diff;\n\t\t}\n\t\txlv_COLOR.w = 1.0;  \n    }\n}\n\nvoid main() \n{\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(basecolor.a < _AlphaCut)\n        discard;\n    lowp vec4 fristColor=basecolor*_MainColor;\n    lowp vec4 emission = fristColor;\n\n    //----------------------------------------------------------\n    //light\n    calcCOLOR();\n    \n#ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    if(glstate_lightmapRGBAF16 == 1.0){\n        emission.xyz *= lightmap.xyz;\n    }else{\n        emission.xyz *= decode_hdr(lightmap);\n    }\n    if(hasLight){ // have light\n        fristColor = fristColor * xlv_COLOR ;\n        emission = emission + mix(vec4(1.0, 1.0, 1.0, 1.0), fristColor, fristColor.wwww);\n    }\n#else\n\tif(hasLight){ // have light\n        emission = (fristColor * xlv_COLOR) + (fristColor * vec4(fixedAmbient,1.0));\n    }\n#endif\n\n#ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n#endif\n    \n    gl_FragData[0] = emission;\n}","diffuse.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ]\n    }\n}","diffuse.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n//light\r\nlowp mat4 blendMat ;\r\nattribute lowp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform lowp float glstate_lightcount;\r\n\r\nvarying highp vec3 v_N;\r\nvarying highp vec3 v_Mpos;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec2 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\nuniform lowp float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\tint c =int(glstate_lightcount);\r\n\tif(c>0){\r\n\t\t//求世界空间法线\r\n\t\t#ifdef SKIN\r\n\t\tv_N = normalize(mat3(blendMat) * _glesNormal);\r\n\t\t#else\r\n\t\tv_N = _glesNormal;\r\n\t\t#endif\r\n\t\tlowp mat3 normalmat = mat3(glstate_matrix_model);\r\n\t\tv_N =normalize(normalmat*v_N);\r\n\t\tv_Mpos =(glstate_matrix_model * pos).xyz;\r\n\t}\r\n}\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = (1.0 - glstate_lightmapUV) * _glesMultiTexCoord0  + glstate_lightmapUV * _glesMultiTexCoord1;\t//unity lightMap UV ,优先使用UV1,次之UV0 \r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","diffuse_bothside.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ]\n    }\n}","diffuse_nolight.fs.glsl":"precision lowp float;\nuniform lowp sampler2D _MainTex;\nuniform lowp vec4 _MainColor;\nuniform lowp float _AlphaCut;\nvarying mediump vec2 xlv_TEXCOORD0;\n\n//texture2DEtC1Mark\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\nvoid main() \n{\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(basecolor.a < _AlphaCut)\n        discard;\n    lowp vec4 fristColor=basecolor*_MainColor;\n    lowp vec4 emission = fristColor;\n\n    //----------------------------------------------------------\n    \n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n    \n    gl_FragData[0] = emission;\n}","diffuse_nolight.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ]\n    }\n}","diffuse_nolight.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\nvarying mediump vec2 xlv_TEXCOORD0;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n\tlowp mat4 blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n\n#endif\n\n\nvoid main()\n{\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\n    gl_Position =position;\n}","diffuse_nolight_bothside.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse_nolight\",\n                \"fs\": \"diffuse_nolight\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ]\n    }\n}","dof.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH  \nprecision highp float;  \n#else  \nprecision mediump float;  \n#endif \n\nuniform sampler2D _MainTex;//清晰图\nuniform sampler2D _BlurTex;//模糊的图\nuniform sampler2D _DepthTex;//深度图\n\nuniform highp float _focalDistance;//焦点位置\nuniform highp float _farBlurScale;\nuniform highp float _nearBlurScale;\n\n\nvarying highp vec2 xlv_TEXCOORD0;\n\nconst highp float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst highp vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst highp vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nhighp float unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\n\n//texture2DEtC1Mark\n\nvoid main() \n{\n\tlowp vec4 basecolor =texture2D(_MainTex,xlv_TEXCOORD0);\n    lowp vec4 blurcolor=texture2D(_BlurTex,xlv_TEXCOORD0);\n    lowp vec4 depthcolor=texture2D(_DepthTex,xlv_TEXCOORD0);\n    highp float depth=unpackRGBAToDepth(depthcolor);\n\n\n    lowp vec4 finalcolor=basecolor;\n    if(depth>_focalDistance)\n    {\n        depth=clamp((depth-_focalDistance)*_farBlurScale,0.0,1.0);\n        finalcolor=mix(basecolor,blurcolor,depth);\n        //finalcolor=mix(blurcolor,basecolor,1.0);//为1的时候取basecolor\n        //finalcolor=vec4(depth,depth,depth,1.0);\n    }\n    gl_FragData[0] = finalcolor;\n}","dof.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_farBlurScale('farBlurScale',Range(0.0,1.0)) = 1.0\",\n        \"_farBlurScale('farBlurScale',Range(0.0,1.0)) = 100.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"dof\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"dof\"\n            }\n        ]\n    }\n}","f14trans.fs.glsl":"uniform mediump sampler2D _Main_Tex;\n\nvarying lowp vec4 xlv_COLOR;\nvarying mediump vec2 xlv_TEXCOORD0;       \n//texture2DEtC1Mark\n   \nvoid main() \n{\n    lowp vec4 basecolor = texture2D(_Main_Tex, xlv_TEXCOORD0);\n    gl_FragData[0] =basecolor*xlv_COLOR;\n    //gl_FragData[0] =vec4(1,0,0,1);\n}","f14trans.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;   \nattribute lowp vec4 _glesColor;\n\nuniform lowp vec4 _Main_Color;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _Main_Tex_ST;\n\n\nvarying lowp vec4 xlv_COLOR;\nvarying mediump vec2 xlv_TEXCOORD0;                \nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz,1.0);\n    xlv_COLOR = _Main_Color*_glesColor;\n\txlv_TEXCOORD0 =_glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n                \n    gl_Position = (glstate_matrix_mvp *tmpvar_1);  \n}","f4skin.fs.glsl":"precision lowp float;\nuniform lowp sampler2D _MainTex;\nuniform lowp vec4 _MainColor;\nuniform lowp float _AlphaCut;\n// varying mediump vec2 xlv_TEXCOORD0;\n\n// #ifdef LIGHTMAP\n// uniform lowp sampler2D _LightmapTex;\n// varying mediump vec2 lightmap_TEXCOORD;\n// lowp vec3 decode_hdr(lowp vec4 data)\n// {\n//     lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n//     return data.rgb * power * 2.0 ;\n// }\n// #endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\nvarying highp vec4 vcolor;\n\n//texture2DEtC1Mark\n\nvoid main()\n{\n    // lowp vec4 basecolor = vec4(1);\n    // // lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\n    // // if(basecolor.a < _AlphaCut)\n    // //     discard;\n    // lowp vec4 fristColor=basecolor*_MainColor;\n    // lowp vec4 emission = fristColor;\n\n    // //----------------------------------------------------------\n\n    // // #ifdef LIGHTMAP\n    // // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    // // emission.xyz *= decode_hdr(lightmap);\n    // // #endif\n\n    // #ifdef FOG\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    // #endif\n\n    gl_FragData[0] = vec4(pow(vcolor.rgb, vec3(1./2.2)), vcolor.a);\n    // gl_FragData[0] = vec4(1, 0, 0, 1);\n}","f4skin.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"boneSampler('MainTex',Texture)='white'{}\",\n        \"boneSamplerTexelSize('boneSamplerTexelSize',float)=0.1\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"f4skin\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"f4skin\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"f4skin\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"f4skin\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"f4skin\",\n                \"fs\": \"f4skin\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"f4skin\",\n                \"fs\": \"f4skin\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ]\n    }\n}","f4skin.vs.glsl":"precision highp float;\n\nattribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\nattribute highp vec4 _glesColor;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n// varying mediump vec2 xlv_TEXCOORD0;\n\n// #ifdef LIGHTMAP\n// attribute mediump vec4 _glesMultiTexCoord1;\n// uniform mediump vec4 glstate_lightmapOffset;\n// // uniform mediump float glstate_lightmapUV;\n// varying mediump vec2 lightmap_TEXCOORD;\n// #endif\n\n\n// NOTE: diffuse cap\nvarying lowp vec3 v_N;\nvarying lowp vec3 v_Mpos;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying mediump vec2 lightmap_TEXCOORD;\n\n\n//texture2DEtC1Mark\n\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#define SKIN2\n\n#define SKIN\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\n\n#ifdef SKIN2\n// uniform highp mat4 glstate_matrix_bones[24];\nuniform highp sampler2D boneSampler;\nuniform highp float boneSamplerTexelSize;\nuniform highp vec4 boneSampler_TexelSize;\n\nmat4 readMatrixSampler(sampler2D smp, float index) {\n    float offset = index * 4.;\n    return mat4(\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 0.5), 0)),\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 1.5), 0)),\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 2.5), 0)),\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 3.5), 0))\n\t\t);\n}\nhighp vec4 calcVertexF4(highp vec4 srcVertex) {\n\tmat4 mat = _glesBlendWeight4[0] * readMatrixSampler(boneSampler, _glesBlendIndex4[0])\n\t\t\t+ _glesBlendWeight4[1] * readMatrixSampler(boneSampler, _glesBlendIndex4[1])\n\t\t\t+ _glesBlendWeight4[2] * readMatrixSampler(boneSampler, _glesBlendIndex4[2])\n\t\t\t+ _glesBlendWeight4[3] * readMatrixSampler(boneSampler, _glesBlendIndex4[3]);\n\treturn mat * srcVertex;\n}\n#endif\n\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tmat4 matrix = mat4(\n\t1.0-yy-zz, xy+zw, xz-yw, 0,\n\txy-zw, 1.0-xx-zz, yz + xw, 0,\n\txz + yw, yz - xw, 1.0-xx-yy, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n\tlowp mat4 blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n\n#endif\n\nvarying highp vec4 vcolor;\n\n\nvoid main()\n{\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\tmat4 mat = _glesBlendWeight4[0] * readMatrixSampler(boneSampler, _glesBlendIndex4[0])\n\t\t\t+ _glesBlendWeight4[1] * readMatrixSampler(boneSampler, _glesBlendIndex4[1])\n\t\t\t+ _glesBlendWeight4[2] * readMatrixSampler(boneSampler, _glesBlendIndex4[2])\n\t\t\t+ _glesBlendWeight4[3] * readMatrixSampler(boneSampler, _glesBlendIndex4[3]);\n\t// mat = mat4(\n\t// \tvec4(1, 0, 0, 0),\n\t// \tvec4(0, 1, 0, 0),\n\t// \tvec4(0, 0, 1, 0),\n\t// \tvec4(0, 0, 0, 1)\n\t// \t);\n\t// mat = _glesBlendWeight4.x * glstate_matrix_bones[int(_glesBlendIndex4.x)]\n\t// \t\t+ _glesBlendWeight4.y * glstate_matrix_bones[int(_glesBlendIndex4.y)]\n\t// \t\t+ _glesBlendWeight4.z * glstate_matrix_bones[int(_glesBlendIndex4.z)]\n\t// \t\t+ _glesBlendWeight4.w * glstate_matrix_bones[int(_glesBlendIndex4.w)];\n\tvcolor = vec4(texture2D(boneSampler, _glesVertex.xz / vec2(8., 0)/ 3.).rgb, 1);\n    // xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    // //----------------------------------------------------------\n    // #ifdef LIGHTMAP\n    // mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    // lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    // lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    // lightmap_TEXCOORD = vec2(u,v);\n    // #endif\n\n    #ifdef SKIN\n    // position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n\tposition = mat * position;\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\n    gl_Position =position;\n}","fakepbr.fs.glsl":"uniform lowp sampler2D _albedo;\nuniform lowp sampler2D _normal;\nuniform lowp sampler2D _gloss;\nuniform lowp sampler2D _specular;\nuniform lowp sampler2D _opacity;\nuniform lowp float _cutvalue;\nuniform lowp vec4 glstate_eyepos;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\n\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying lowp vec3 posWorld;\nvarying lowp vec3 normalDir;\nvarying lowp vec3 tangentDir;\nvarying lowp vec3 bitangentDir;\n\n//texture2DEtC1Mark\n\n\n    //calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n\n    return diffuse;\n}\n\nlowp float calcSpec(lowp vec3 N,lowp vec3 worldpos,lowp vec3 eyedir,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n\n    lowp float shininess=30.0;//高光系数\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //三种光源 计算出三个 高光强度，然后根据条件选出一个\n    lowp float spec =pow(clamp(dot(N,normalize(L+eyedir)),0.0,1.0), shininess);\n    lowp float specD =pow(clamp(dot(N,normalize(L2+eyedir)),0.0,1.0), shininess);\n    spec= mix(spec,spec*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    spec= mix(specD,spec,lightPos.w);\n\n    //highp  float specularLight = pow(clamp(dot(N,H),0.0,1.0), shininess);\n\n    return spec;\n}\n\nvoid main() \n{\n    lowp float _opacity_var = texture2D(_opacity,xlv_TEXCOORD0).g;\n    if(_opacity_var<0.5)  discard;\n\n\n    //clip(step(_cutvalue,_opacity_var) - 0.5);\n\n    lowp float diff=0.0;\n    lowp float specularPower=0.0;\n    lowp mat3 TBNmat = mat3( tangentDir, bitangentDir, normalDir);\n    lowp vec3 eyeDir =glstate_eyepos.xyz-posWorld;\n    for(int i=0;i<8;i++)\n    {\n        lowp vec3 normal;// = TBN*N;\n\t\tnormal =  texture2D(_normal, xlv_TEXCOORD0).xyz *2.0 -1.0;\n        normal =normalize(normal);\n\t\tnormal =TBNmat*(normal);\n        \n        diff+=calcDiffuse(normal,posWorld,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);\n        specularPower+=calcSpec(normal,posWorld,eyeDir,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);\n    }\n\n    //gloss //假的光洁度，只影响了高光\n    lowp float Pi = 3.141592654;\n    lowp float InvPi = 0.31830988618;\n    lowp vec4 _gloss_var = texture2D(_gloss,xlv_TEXCOORD0);\n    lowp float gloss = _gloss_var.r;\n    lowp float specPow = exp2( gloss * 10.0+1.0);\n    //spec //受到高光贴图的过滤\n    lowp float normTerm = (specPow + 8.0 ) / (8.0 * Pi);\n    lowp vec4 specularColor = texture2D(_specular,xlv_TEXCOORD0);\n    lowp float specularMonochrome = max( max(specularColor.r, specularColor.g), specularColor.b);\n    specularColor*=pow(specularPower,specPow)*normTerm;\n    //diffuse\n\n    lowp vec4 diffuseColor= texture2D(_albedo, xlv_TEXCOORD0);//光照颜色\n    diffuseColor *= 1.0-specularMonochrome;//均衡能量\n    lowp vec3 directDiffuse = vec3(diff,diff,diff);//直接光照\n    lowp vec3 indirectDiffuse = vec3(0.3,0.3,0.3);//间接光照\n\n    lowp vec4 col_1;    \n    lowp vec4 prev_2;\n    lowp vec4 final = (diffuseColor*vec4(directDiffuse+indirectDiffuse,1.0)  + specularColor);\n\n    gl_FragData[0] = final;\n\n}","fakepbr.shader.json":"{\n    \"layer\": \"geometry\",\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"fakepbr\",\n                \"fs\": \"fakepbr\",\n                \"zwrite\": \"on\",\n                \"ztest\": \"lequal\"\n            }\n        ],\n        \"base_fog\": [],\n        \"skin\": [],\n        \"lightmap\": [],\n        \"quad\": [],\n        \"base_depth\": []\n    }\n}","fakepbr.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nattribute lowp vec3 _glesTangent;\nattribute lowp vec3 _glesNormal;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST; \n\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying highp vec3 posWorld;\nvarying lowp vec3 normalDir;\nvarying lowp vec3 tangentDir;\nvarying lowp vec3 bitangentDir;\nvoid main()\n{\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw; \n    posWorld = (glstate_matrix_model * _glesVertex).xyz;\n    highp mat3 normalmat = mat3(glstate_matrix_model);\n\n    normalDir = normalize(normalmat*_glesNormal);\n    tangentDir = normalize(normalmat*_glesTangent);\n    bitangentDir = cross(normalDir,tangentDir);\n\n    gl_Position = (glstate_matrix_mvp * _glesVertex);\n}","filter_quad.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D _MainTex;\nuniform lowp float _FilterType;\nuniform lowp float _Step;\nvarying highp vec2 xlv_TEXCOORD0;\n//texture2DEtC1Mark\n\nvoid main()\n{\n    vec2 tcOffset[25];\n    lowp float xInc = _Step / 1024.0;\n    lowp float yInc = _Step / 1024.0;\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            tcOffset[(((i * 5) + j) * 2)] = vec2((-2.0 * xInc) + (float(i) * xInc), (-2.0 * yInc) + (float(j) * yInc));\n        }\n    }\n\n    // 灰度图\n    if (_FilterType == 1.)\n    {\n        float gray = dot(texture2D(_MainTex, xlv_TEXCOORD0.xy).rgb, vec3(0.299, 0.587, 0.114));\n        gl_FragData[0] = vec4(gray, gray, gray, 1.0);\n    }\n\n    // 棕褐色调\n    else if (_FilterType == 2.)\n    {\n        float gray = dot(texture2D(_MainTex, xlv_TEXCOORD0.xy).rgb, vec3(0.299, 0.587, 0.114));\n        gl_FragData[0] = vec4(gray * vec3(1.2, 1.0, 0.8), 1.0);\n    }\n\n    // 反色\n    else if (_FilterType == 3.)\n    {\n        vec4 color = texture2D(_MainTex, xlv_TEXCOORD0.xy);\n        gl_FragData[0] = vec4(1.0 - color.rgb, 1.0);\n    }\n\n    // 高斯滤波\n    else if (_FilterType == 4.)\n    {\n        vec4 sample[25];\n        for (int i = 0; i < 25; i++)\n        {\n            sample[i] = texture2D(_MainTex, xlv_TEXCOORD0.xy + tcOffset[i]);\n        }\n\n        // 1  4  7  4 1\n        // 4 16 26 16 4\n        // 7 26 41 26 7 / 273 (除权重总和)\n        // 4 16 26 16 4\n        // 1  4  7  4 1\n        gl_FragData[0] = (\n                            (1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +\n                            (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +\n                            (7.0  * (sample[2] + sample[10] + sample[14] + sample[22])) +\n                            (16.0 * (sample[6] + sample[8]  + sample[16] + sample[18])) +\n                            (26.0 * (sample[7] + sample[11] + sample[13] + sample[17])) +\n                            (41.0 * sample[12])\n                         ) / 273.0;\n    }\n\n    // 均值滤波\n    else if (_FilterType == 5.)\n    {\n        vec4 sample[25];\n        for (int i = 0; i < 25; i++)\n        {\n            sample[i] = texture2D(_MainTex, xlv_TEXCOORD0.xy + tcOffset[i]);\n        }\n\n        vec4 color;\n        for (int i = 0; i < 25; i++)\n        {\n            color += sample[i];\n        }\n\n        gl_FragData[0] = color / 25.0;\n    }\n\n    // 锐化\n    else if (_FilterType == 6.)\n    {\n        vec4 sample[25];\n        for (int i = 0; i < 25; i++)\n        {\n            sample[i] = texture2D(_MainTex, xlv_TEXCOORD0.xy + tcOffset[i]);\n        }\n\n        // -1 -1 -1 -1 -1\n        // -1 -1 -1 -1 -1\n        // -1 -1 25 -1 -1\n        // -1 -1 -1 -1 -1\n        // -1 -1 -1 -1 -1\n        vec4 color = sample[12] * 25.0;\n        for (int i = 0; i < 25; i++)\n        {\n            if (i != 12)\n            {\n                color -= sample[i];\n            }\n        }\n\n        gl_FragData[0] = color;\n    }\n\n    // 膨胀\n    else if (_FilterType == 7.)\n    {\n        vec4 sample[25];\n        vec4 maxValue = vec4(0.0);\n        for (int i = 0; i < 25; i++)\n        {\n            sample[i] = texture2D(_MainTex, xlv_TEXCOORD0.xy + tcOffset[i]);\n            maxValue = max(sample[i], maxValue);\n        }\n\n        gl_FragData[0] = maxValue;\n    }\n\n    // 腐蚀\n    else if (_FilterType == 8.)\n    {\n        vec4 sample[25];\n        vec4 minValue = vec4(1.0);\n        for (int i = 0; i < 25; i++)\n        {\n            sample[i] = texture2D(_MainTex, xlv_TEXCOORD0.xy + tcOffset[i]);\n            minValue = min(sample[i], minValue);\n        }\n        gl_FragData[0] = minValue;\n    }\n\n    // 标准\n    else\n    {\n        gl_FragData[0] = texture2D(_MainTex, xlv_TEXCOORD0.xy);\n    }\n}","filter_quad.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_FilterType('FilterType',Float)=0\",\n        \"_Step('Step',Float)=1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"filter_quad\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"filter_quad\"\n            }\n        ]\n    }\n}","flowwater_new.fs.glsl":"uniform lowp sampler2D _MainTex;  \nvarying mediump vec2 _base_uv;\nvarying lowp vec4 attcolor;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//texture2DEtC1Mark\n\n\nvoid main() \n{\n    lowp vec4 basecolor = texture2D(_MainTex, _base_uv);\n    lowp vec4 emission=basecolor*attcolor;\n\n    #ifdef FOG\n    //emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    emission= mix(vec4(0,0,0,0), emission, factor);\n    #endif\n\n    gl_FragData[0] =emission;\n}","flowwater_new.shader.json":"{\n  \"layer\": \"transparent\",\n  \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n\t\t    \"_MainColor('MainColor',color)=(1,1,1,1)\"\n    ],\n  \"queue\": 0,\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"ccw\",\n        \"zwrite\": \"off\",\n        \"vs\": \"flowwater_new\",\n        \"fs\": \"flowwater_new\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"ccw\",\n        \"zwrite\": \"off\",\n        \"vs\": \"flowwater_new\",\n        \"fs\": \"flowwater_new\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","flowwater_new.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nattribute lowp vec4 _glesColor;\n\nuniform lowp vec4 _MainColor;\nuniform lowp float _alphaRate;\nuniform lowp float _colorRate;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\nuniform lowp float _speedu;\nuniform lowp float _speedv;\nuniform lowp float glstate_timer;\n\nvarying mediump vec2 _base_uv;\nvarying lowp vec4 attcolor;\n\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n\thighp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    lowp vec2 _speed= vec2(_speedu,_speedv);\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw+ _speed * glstate_timer;\n\tattcolor= _MainColor;\n\tattcolor.rgb=attcolor.rgb*_colorRate;\n\tattcolor.a=attcolor.a*_alphaRate;\n\t\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start); \n    factor = clamp(factor, 0.0, 1.0);  \n    #endif\n\n\tposition = (glstate_matrix_mvp * position);\n\tgl_Position = position;\n}\n\n","gaussianBlur.fs.glsl":"uniform sampler2D _MainTex;\nuniform lowp float _BlurGap; //卷积每层间隔单位\nuniform lowp float _BlurSigma; //二维正太分布中的西格玛值\nuniform lowp float _BlurLayer; //卷积层数\nuniform highp vec4 _MainTex_TexelSize;\nvarying highp vec2 xlv_TEXCOORD0;\n\nconst lowp float max_Num = 100.0;\n\n//texture2DEtC1Mark\n\n//高斯模糊 算法获取权重矩阵 rx ,ry 以当前采样点 为原点的相对坐标\nlowp float getGausWeight(lowp float rx,lowp float ry)\n{\n\tlowp float pi = 3.1415926535898 ;\n\tlowp float xDistance = float(rx*rx);\n\tlowp float yDistance = float(ry*ry);\n\tlowp float sigma22 = 2.0*_BlurSigma*_BlurSigma;\n\tlowp float sigma22PI = pi*sigma22;\n\n\treturn exp(-(xDistance + yDistance)/sigma22)/sigma22PI;\n}\n\nvoid main() \n{\n\tlowp float size =2.0 * _BlurLayer + 1.0;\n\n\thighp vec4 color;\n\thighp vec4 sample;\n\tlowp float tx;\n\tlowp float ty;\n\tlowp float rx;\n\tlowp float ry;\n\tlowp float sum;\n\tlowp float tempWeight;\n\tfor(lowp float i=0.0 ; i<max_Num ; i +=1.0){\n\t\tif(i >=size) {break;}\n\t\tfor(lowp float j=0.0 ; j<max_Num ; j +=1.0){\n\t\t\tif(j >=size) {break;}\n\t\t\trx = -_BlurLayer + i;\n\t\t\try = -_BlurLayer + j;\n\t\t\ttx = rx * _MainTex_TexelSize.x * _BlurGap;\n\t\t\tty = ry * _MainTex_TexelSize.y * _BlurGap;\n\t\t\ttempWeight = getGausWeight(rx,ry);\n\t\t\tsample = texture2D(_MainTex,vec2(xlv_TEXCOORD0.x + tx ,xlv_TEXCOORD0.y + ty));   \n\t\t\tcolor +=sample * tempWeight;  \n\t\t\tsum += tempWeight; \n\t\t}\n\t}\n\n    gl_FragData[0] = color/sum;  \n}\n\n\n\n\n\n\n\n\n","gaussianBlur.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_BlurGap('_BlurGap',float)=1.0\",\n        \"_BlurSigma('BlurSigma',float)=2.0\",\n        \"_BlurLayer('BlurLayer',float)=3.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"gaussianBlur\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"gaussianBlur\"\n            }\n        ]\n    }\n}","hdr_quad.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_K('K',Range(0.5,2.0))=1.5\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,1,1)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"hdr_quad_0\"\n            },\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"hdr_quad_1\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"hdr_quad_0\"\n            },\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"hdr_quad_1\"\n            }\n        ]\n    }\n}","hdr_quad_0.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nconst vec2 texSize = vec2(256., 256.);\n\nuniform sampler2D _MainTex;\nvarying highp vec2 xlv_TEXCOORD0;\n\n//texture2DEtC1Mark\n\nvec4 blur_filter(mat3 filter, vec2 filter_pos_delta[9], sampler2D image, vec2 xy, vec2 texSize)\n{\n    vec4 final_color = vec4(0., 0., 0., 0.);\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            vec2 new_xy = vec2(xy.x + filter_pos_delta[3 * i + j].x, xy.y + filter_pos_delta[3 * i + j].y);\n            vec2 new_uv = vec2(new_xy.x / texSize.x, new_xy.y / texSize.y);\n            final_color += texture2D(_MainTex, new_uv) * filter[i][j];\n        }\n    }\n    return final_color;\n}\n\nvoid main()\n{\n    vec2 filter_pos_delta[9];\n    filter_pos_delta[0] = vec2(-1., -1.);\n    filter_pos_delta[1] = vec2(0., -1.);\n    filter_pos_delta[2] = vec2(1., -1.);\n    filter_pos_delta[4] = vec2(-1., 0.);\n    filter_pos_delta[5] = vec2(0., 0.);\n    filter_pos_delta[6] = vec2(1., 0.);\n    filter_pos_delta[7] = vec2(-1., 1.);\n    filter_pos_delta[8] = vec2(0., 1.);\n    filter_pos_delta[3] = vec2(1., 1.);\n\n    mat3 filter = mat3(1. / 16., 1. / 8., 1. / 16.,\n                        1. / 8., 1. / 4., 1. / 8.,\n                        1. / 16., 1. / 8., 1. / 16.);\n\n    vec2 xy = vec2(xlv_TEXCOORD0.x * texSize.x, xlv_TEXCOORD0.y * texSize.y);\n\n    vec4 color = blur_filter(filter, filter_pos_delta, _MainTex, xy, texSize);\n\n    gl_FragData[0] = color;\n}","hdr_quad_1.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D _MainTex;\nuniform float _K;\nvarying highp vec2 xlv_TEXCOORD0;\n\n//texture2DEtC1Mark\n\nvec4 xposure(vec4 color, float gray, float ex)\n{\n    float b = (4. * ex - 1.);\n    float a = 1. - b;\n    float f = gray * (a * gray + b);\n    return color * f;\n}\n\nvoid main()\n{\n    vec4 color = texture2D(_MainTex, xlv_TEXCOORD0);\n    float lum = .3 * color.x + .59 * color.y + .11 * color.z;\n    gl_FragData[0] = xposure(color, lum, _K);\n}","light1.fs.glsl":"uniform lowp sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying mediump vec2 xlv_TEXCOORD0;   \n//texture2DEtC1Mark\n\nvoid main() \n{\n    lowp vec4 tmpvar_3= (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    lowp vec4 tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), tmpvar_3, tmpvar_3.wwww);\n    gl_FragData[0] = tmpvar_4;\n}","light1.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"light1\",\n                \"fs\": \"light1\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ],\n        \"shadowuse\": []\n    }\n}","light1.vs.glsl":"attribute highp vec3 _glesVertex;   \nattribute lowp vec3 _glesNormal;   \nattribute lowp vec4 _glesColor;                  \nattribute lowp vec4 _glesMultiTexCoord0;        \nuniform highp mat4 glstate_matrix_mvp;      \nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_modelview;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp float glstate_lightcount;\n\nvarying lowp vec4 xlv_COLOR;                \nvarying mediump vec2 xlv_TEXCOORD0;     \n\n//calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n\n    return diffuse;\n     \n}\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;    \n\n    //求世界空间法线\n    lowp mat3 normalmat = mat3(glstate_matrix_model);\n    lowp vec3 N =normalize(normalmat*_glesNormal);\n\n    highp vec3 worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;\n\n    lowp float diff=0.0;\n    //calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n    for(int i=0;i<8;i++)\n    {\n        int c =int(glstate_lightcount);\n        if(i>=c)break;\n        diff += calcDiffuse(N,worldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);\n    }\n\n    xlv_COLOR = vec4(diff,diff,diff,1.0);         \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}","light2.fs.glsl":"uniform lowp sampler2D _MainTex;\n\n\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\n\nvarying highp vec3 vWorldpos;\nvarying lowp vec3 vNormal;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying lowp vec3 vEyepos;\n\n//texture2DEtC1Mark\n\n\n//calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n\n    return diffuse;\n}\n\nlowp float calSpec(lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir)\n{\n   // highp vec3 ks=vec3(0.5,0.5,0.5);//物体对于反射光线的衰减系数\n    lowp float shininess=1.0;//高光系数\n   // highp vec3 lightcolor=vec3(1.0,1.0,1.0);\n\n    lowp vec3 N=normalize(vNormal);\n\n   // highp vec3 L = normalize(lightPos.xyz - worldpos); \n    lowp vec3 L = normalize(-lightDir.xyz); \n    lowp vec3 v=normalize(vEyepos-worldpos);\n    lowp vec3 H=normalize(L+v);\n    //highp vec3 R=reflect(-L,N);\n    //R=normalize(R);\n\n    lowp  float specularLight = pow(clamp(dot(N,H),0.0,1.0), shininess);\n\n    //highp vec3 spec=ks*lightcolor*specularLight;\n    lowp float spec=specularLight;\n    return spec;\n}\nvoid main() \n{\n    lowp float diff=0.0;\n    lowp float specularColor=0.0;\n    for(int i=0;i<8;i++)\n    {\n        diff+=calcDiffuse(vNormal,vWorldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);\n        specularColor+=calSpec(vWorldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i]);\n    }\n    lowp vec4 xlv_COLOR=vec4(diff,diff,diff,1.0);\n    xlv_COLOR+=vec4(specularColor,specularColor,specularColor,1.0);\n\n    lowp vec4 col_1;    \n    lowp vec4 prev_2;\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n\n    prev_2 = tmpvar_3;\n    lowp vec4 tmpvar_4;\n    tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n    col_1 = tmpvar_4;\n    \n   gl_FragData[0] = col_1;\n    //gl_FragData[0]=vec4(specularColor,1.0);\n    //gl_FragData[0] = xlv_COLOR;\n}","light2.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n\t\t\"_NormalTex('NormalTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"light2\",\n                \"fs\": \"light2\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","light2.vs.glsl":"attribute highp vec3 _glesVertex;   \nattribute lowp vec3 _glesNormal;   \nattribute lowp vec4 _glesColor;                  \nattribute mediump vec4 _glesMultiTexCoord0; \n\nuniform lowp sampler2D _NormalTex;   //normal map\n\nuniform highp mat4 glstate_matrix_mvp;      \nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_modelview;\nuniform highp vec4 glstate_eyepos;\n\nvarying lowp vec3 vWorldpos;\nvarying lowp vec3 vNormal;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying lowp vec3 vEyepos;\n\n//texture2DEtC1Mark\n\n\nvoid main()\n{\n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz =_glesVertex;\n    vWorldpos=(glstate_matrix_model*tmpvar_1).xyz;\n    //vWorldpos =glstate_matrix_model[3].xyz;//计算输出定点位置\n\n    vEyepos=glstate_eyepos.xyz;\n      \n    //求世界空间法线\n    lowp mat4 vnormalMat = glstate_matrix_model;\n    vnormalMat[3] =vec4(0,0,0,1);\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    lowp vec3 NormalMap = texture2D(_NormalTex, xlv_TEXCOORD0).rgb;\n    lowp vec3 N = normalize(NormalMap * 2.0 - vec3(1.0));\n\n    vNormal =normalize((vec4(_glesNormal,1)*vnormalMat).xyz);\n\n    //vNormal=N;\n\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}\n\n","light3.fs.glsl":"\nuniform lowp sampler2D _MainTex;  \nuniform lowp sampler2D _NormalTex;   //normal map\n\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp float glstate_lightcount;\n//varying lowp vec4 xlv_COLOR;     \n//varying highp vec3 xlv_Position;                                             \nvarying mediump vec2 xlv_TEXCOORD0; \n//varying highp vec3 xlv_Normal; \n//varying highp mat4 normalmat;\nvarying lowp mat3 TBNmat;\nvarying lowp vec3 worldpos; \nvarying lowp vec3 eyedir;\n\n//texture2DEtC1Mark\n\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot);\nlowp float calcSpec(lowp vec3 N,lowp vec3 worldpos,lowp vec3 eyedir,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot);\nvoid main() \n{\n    //不需要法线图时，normal 就是这个N\n    //highp vec3 N =normalize((vec4(xlv_Normal,1)*normalmat).xyz);\n\n    lowp float diff=0.0;\n    lowp float spec=0.0;\n    //calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n    for(int i=0;i<8;i++)\n    {\n        int c =int(glstate_lightcount);\n        if(i>=c)break;\n    \n\t\tlowp vec4 lpos=glstate_vec4_lightposs[i];\n\t\t//lpos.xyz = TBN*lpos.xyz;\n\t\tlowp vec4 ldir =glstate_vec4_lightdirs[i];\n\t\t//ldir.xyz = TBN*ldir.xyz;\n\t\t\n\t\t//这是进入切空间的原因\n\t\tlowp vec3 normal;// = TBN*N;\n\t\tnormal =  texture2D(_NormalTex, xlv_TEXCOORD0).xyz *2.0 -1.0;\n        normal =normalize(normal);\n\t\tnormal =TBNmat*(normal);\n\n\n        diff += calcDiffuse(normal,worldpos,lpos,ldir,glstate_float_spotangelcoss[i]);\n        spec += calcSpec(normal,worldpos,eyedir,lpos,ldir,glstate_float_spotangelcoss[i]);\n    }\n\t//diff=1.0;\n\tlowp vec4 color = vec4(diff,diff,diff,1.0);       \n    lowp vec4 colorspec =vec4(spec,spec,spec,1.0);\n    lowp vec4 fcolor;\n    fcolor = (color * texture2D(_MainTex, xlv_TEXCOORD0) + colorspec);\n\n    gl_FragData[0] = fcolor;\n}\n\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n\n    return diffuse;\n     \n}\nlowp float calcSpec(lowp vec3 N,lowp vec3 worldpos,lowp vec3 eyedir,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n\n    lowp float shininess=30.0;//高光系数\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //三种光源 计算出三个 高光强度，然后根据条件选出一个\n    lowp float spec =pow(clamp(dot(N,normalize(L+eyedir)),0.0,1.0), shininess);\n    lowp float specD =pow(clamp(dot(N,normalize(L2+eyedir)),0.0,1.0), shininess);\n    spec= mix(spec,spec*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    spec= mix(specD,spec,lightPos.w);\n\n    //highp  float specularLight = pow(clamp(dot(N,H),0.0,1.0), shininess);\n\n    return spec;\n}\n","light3.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n\t\t\"_NormalTex('NormalTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"cw\",\n                \"vs\": \"light3\",\n                \"fs\": \"light3\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","light3.vs.glsl":"\n// in  attributes from our SpriteBatch\nattribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nattribute vec4 _glesColor;\nattribute lowp vec3 _glesNormal;\nattribute lowp vec3 _glesTangent;  \n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_modelview;\nuniform highp vec4 glstate_eyepos;\n\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\n\n\n\n// out  varyings to our fragment shader\n//varying highp vec4 xlv_COLOR;\n//varying highp vec3 xlv_Position;      \nvarying mediump vec2 xlv_TEXCOORD0;\n//varying highp vec3 xlv_Normal;\n\n//varying highp mat4 normalmat;\nvarying lowp mat3 TBNmat;\nvarying lowp vec3 worldpos;\nvarying lowp vec3 eyedir;\n\n\nlowp mat3 calBTNMatrix(lowp mat4 NormalMatToWorld,lowp vec3 _normal,lowp vec3 _tangent)\n{\n    lowp vec3 normal=normalize(vec3(NormalMatToWorld*vec4(_normal,0.0)));\n    lowp vec3 tangent=normalize(vec3(NormalMatToWorld*vec4(_tangent,0.0)));\n    lowp vec3 binormal=cross(normal,tangent);\n  \treturn (mat3(tangent,binormal,normal));\n\n}\nvoid main()\n{\n\t//求世界空间法线\n  \thighp mat4  normalmat = glstate_matrix_model;\n\tnormalmat[3] =vec4(0,0,0,1);\n\n   \tTBNmat=calBTNMatrix(normalmat,_glesNormal,_glesTangent);\n\n    worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;\n\teyedir = glstate_eyepos.xyz - worldpos;\n\n\t//xlv_COLOR = _glesColor;\n\t//xlv_Normal = _glesNormal;\n\t//xlv_Position = _glesVertex.xyz;\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\tgl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\n}\n\n","linetrail.fs.glsl":"\nprecision mediump float;\n\nvarying vec2 v_uv;\n\nuniform vec4 _TintColor;\nuniform sampler2D _MainTex;\nuniform vec4 _MainTex_ST;\n\nvoid main()\n{\n    vec4 finalColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    vec2 uv = v_uv;\n    uv = uv * _MainTex_ST.xy + _MainTex_ST.zw;\n    finalColor = finalColor * _TintColor * texture2D(_MainTex, uv);\n\n    gl_FragColor = finalColor;\n}","linetrail.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"linetrail\",\n        \"fs\": \"linetrail\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"linetrail\",\n        \"fs\": \"linetrail\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","linetrail.vs.glsl":"\nprecision mediump float;  \n\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\nattribute vec4 _glesColor;\n\nuniform mat4 glstate_matrix_mvp;\n\nvarying vec2 v_uv;\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n    //输出uv\n    v_uv = _glesMultiTexCoord0.xy;\n\n    //计算投影坐标\n    gl_Position = glstate_matrix_mvp * position;\n}","mask_add_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_add_tint_uvroll.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,0,1)\",\n        \"_speedu('speedu',Float) = -1\",\n        \"_speedv('speedv',Float) = 0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_blend_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,0,1)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_blend_tint_uvroll.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,0,1)\",\n        \"_speedu('speedu',Float) = -1\",\n        \"_speedv('speedv',Float) = 0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"mask_trans_tint\",\n                \"fs\": \"mask_trans_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","mask_trans_tint.fs.glsl":"uniform sampler2D _MainTex; \nuniform sampler2D _Mask; \nuniform mediump vec4 _Main_Color;\n\nvarying mediump vec2 _maintex_uv;\nvarying mediump vec2 _mask_uv;\n\nuniform lowp float _mixColorRate;\nuniform lowp float _mixAlphaRate;\n\n//texture2DEtC1Mark\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\nvoid main()    \n{\n    highp vec4 basecolor=texture2D(_MainTex,_maintex_uv);\n    highp vec4 maskcolor=texture2D(_Mask,_mask_uv);\n\n    lowp vec3 tempcolor=_Main_Color.rgb*basecolor.rgb*maskcolor.rgb*_mixColorRate;\n    lowp float tempAlpha=_Main_Color.a*basecolor.a*maskcolor.a*_mixAlphaRate;\n    lowp vec4 emission=vec4(tempcolor,tempAlpha);\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n    #ifdef FOG\n    emission= mix(vec4(0,0,0,0), emission, factor);\n\n    //emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n    gl_FragData[0] = emission;\n\n\n}\n","mask_trans_tint.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _MainTex_ST;\nuniform mediump vec4 _Mask_ST;\nvarying mediump vec2 _maintex_uv;\nvarying mediump vec2 _mask_uv;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    _maintex_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    #ifdef SKIN\n    position=calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n    position =glstate_matrix_mvp * position;\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\tgl_Position = position;\n}","mosaic.fs.glsl":"uniform sampler2D _MainTex;\nuniform lowp float _MosaicSize;\nuniform highp vec4 _MainTex_TexelSize;\nvarying highp vec2 xlv_TEXCOORD0;\n//texture2DEtC1Mark\n\nvoid main() //马赛克效果\n{\n    // lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\n    // gl_FragData[0] = tmpvar_3;\n    highp vec2 uv = (xlv_TEXCOORD0*_MainTex_TexelSize.zw);\n    uv = floor(uv/_MosaicSize)*_MosaicSize;\n    uv = uv * _MainTex_TexelSize.xy;\n    gl_FragData[0] = texture2D(_MainTex, uv);\n    // highp vec4 color = texture2D(_MainTex,xlv_TEXCOORD0);\n    // gl_FragData[0] = color * color;\n}","mosaic.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MosaicSize('MosaicSize',float)=5\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"mosaic\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"mosaic\"\n            }\n        ]\n    }\n}","normalmap.fs.glsl":"\nuniform lowp sampler2D _MainTex;  \nuniform lowp sampler2D _NormalTex;   //normal map\n\nuniform highp mat4 glstate_matrix_model;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp float glstate_lightcount;\nvarying lowp vec4 xlv_COLOR;     \nvarying highp vec3 xlv_Position;                                             \nvarying mediump vec2 xlv_TEXCOORD0; \nvarying lowp mat3 TBNmat;\nvarying highp vec3 worldpos; \n\n//texture2DEtC1Mark\n\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot);\n// highp mat3 cotangentFrame(vec3 normal,highp vec3 position,vec2 uv);\n\nvoid main() \n{\n\t//切空间逆矩阵的计算 应该在vertex shader 里面完成，不需要dfdx 和 dfdy\n\t\n\t//mesh 算好切线tangent，然后 normal 和 tangent cross 出 bnormal\n\t//然后合成出切空间逆矩阵，放在这里算不划算\n\tlowp mat3 TBN = TBNmat;//\n\n    lowp mat3 normalmat = mat3(glstate_matrix_model);\n\n\tlowp vec3 N = normalize(TBNmat[2]*normalmat);\n\n    lowp float diff=0.0;\n\n    //calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n    for(int i=0;i<8;i++)\n    {        \n        int c =int(glstate_lightcount);\n        if(i>=c)break;\n\t\tlowp vec4 lpos=glstate_vec4_lightposs[i];\n\t\t//lpos.xyz = TBN*lpos.xyz;\n\t\tlowp vec4 ldir =glstate_vec4_lightdirs[i];\n\t\t//ldir.xyz = TBN*ldir.xyz;\n\t\t\n\t\t//这是进入切空间的原因\n\t\tlowp vec3 normal;// = TBN*N;\n\t\tnormal =  texture2D(_NormalTex, xlv_TEXCOORD0).xyz *2.0 -1.0;\n        normal =normalize(normal);\n\t\tnormal =TBN*(normal);\n\n\t\t\n        diff += calcDiffuse(normal,worldpos,lpos,ldir,glstate_float_spotangelcoss[i]);\n    }\n\t//diff=1.0;\n\tlowp vec4 color = vec4(diff,diff,diff,1.0);       \n\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (color * texture2D(_MainTex, xlv_TEXCOORD0));\n\n    gl_FragData[0] = tmpvar_3;\n}\n\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot)\n{\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(lightPos.xyz - worldpos); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n\n    return diffuse;\n     \n}\n","normalmap.shader.json":"{\n\t\"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n\t\t\"_NormalTex('NormalTex',Texture)='white'{}\"\n    ],\n\t\"passes\": {\n\t\t\"base\": [\n\t\t\t{\n\t\t\t\t\"showface\": \"all\",\n\t\t\t\t\"vs\": \"normalmap\",\n\t\t\t\t\"fs\": \"normalmap\"\n\t\t\t}\n\t\t],\n\t\t\"shadowgen\": [],\n\t\t\"bone\": [],\n\t\t\"shadowuse\": []\n\t}\n}","normalmap.vs.glsl":"\n// in  attributes from our SpriteBatch\nattribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nattribute lowp vec4 _glesColor;\nattribute lowp vec3 _glesNormal;\nattribute lowp vec3 _glesTangent;  \n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_modelview;\nuniform highp vec4 glstate_eyepos;\n\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp float glstate_lightcount;\n\n\n// out  varyings to our fragment shader\nvarying lowp vec4 xlv_COLOR;\nvarying highp vec3 xlv_Position;      \nvarying mediump vec2 xlv_TEXCOORD0;\n\nvarying lowp mat3 TBNmat;\nvarying lowp vec3 worldpos;\n\n\nlowp mat3 calBTNMatrix(lowp mat3 NormalMatToWorld,lowp vec3 _normal,lowp vec3 _tangent)\n{\n    lowp vec3 normal=normalize(NormalMatToWorld*_normal);\n    lowp vec3 tangent=normalize(NormalMatToWorld*_tangent);\n    lowp vec3 binormal=cross(normal,tangent);\n  \treturn (mat3(tangent,binormal,normal));\n\n}\nvoid main()\n{\n\t//求世界空间法线\n    mat3 normalmat = mat3(glstate_matrix_model);\n\t//normalmat[3] =vec4(0,0,0,1);\n\n   \tTBNmat=calBTNMatrix(normalmat,_glesNormal,_glesTangent);\n\n    worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;\n\t//eyedir = glstate_eyepos - worldpos;\n\n\txlv_COLOR = _glesColor;\n\txlv_Position = _glesVertex.xyz;\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\tgl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\n}\n\n\n\n\n","outline.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH  \nprecision highp float;  \n#else  \nprecision mediump float;  \n#endif \nvarying mediump vec2 xlv_TEXCOORD0;       \nuniform lowp sampler2D _DepthTex;   \nuniform lowp sampler2D _MainTex;  \n\n//texture2DEtC1Mark\n\n\nconst float PackUpscale = 256. / 255.; \n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\n\n\nfloat planeDistance(const in vec3 positionA, const in vec3 normalA, \n                    const in vec3 positionB, const in vec3 normalB) \n{\n  vec3 positionDelta = positionB-positionA;\n  float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));\n  return planeDistanceDelta;\n}\n\nvoid main()         \n{\n    lowp vec4 c1=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0.001,0));\n    lowp vec4 c2=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(-0.001,0));\n    lowp vec4 c3=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,0.001));\n    lowp vec4 c4=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,-0.001));\n    lowp float z1 = unpackRGBAToDepth(c1);\n    lowp float z2 = unpackRGBAToDepth(c2);\n    lowp float z3 = unpackRGBAToDepth(c3);\n    lowp float z4 = unpackRGBAToDepth(c4);\n    lowp float d = clamp(  (abs(z2-z1)+abs(z4-z3))*10.0,0.0,1.0);\n    lowp vec4 c=texture2D(_MainTex, xlv_TEXCOORD0);\n    lowp float g = c.r*0.3+c.g*0.6+c.b*0.1;\n\n    gl_FragColor =mix(vec4(g,g,g,1.),vec4(1.0,1.0,0.0,1.0),d);// vec4(g*d,g*d,g*d,1.0);\n}","outline.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_DepthTex('DepthTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"outline\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"outline\"\n            }\n        ]\n    }\n}","particlesystem.fs.glsl":"\nprecision mediump float;\n\nvarying vec2 v_uv;\n\nuniform vec4 _TintColor;\nuniform sampler2D _MainTex;\n\nvarying vec4 v_color;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n    vec4 color = 2.0 * v_color * _TintColor * texture2D(_MainTex, v_uv);\n\n    #ifdef FOG\n        color.xyz = mix(glstate_fog_color.rgb, color.rgb, factor);\n    #endif\n    \n    gl_FragColor = color;\n}","particlesystem.vs.glsl":"\nprecision mediump float;  \n\n//坐标属性\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\n\nuniform vec4 _MainTex_ST;\n\nuniform float _UVSpeedX;\nuniform float _UVSpeedY;\nuniform float glstate_timer;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\n\n#ifdef INSTANCE\n    attribute vec4 a_particle_position;\n    attribute vec4 a_particle_scale;\n    attribute vec4 a_particle_rotation;\n    attribute vec4 a_particle_color;\n    attribute vec4 a_particle_tilingOffset;\n    attribute vec4 a_particle_flipUV;\n#else\n    uniform vec4 a_particle_position;\n    uniform vec4 a_particle_scale;\n    uniform vec4 a_particle_rotation;\n    uniform vec4 a_particle_color;\n    uniform vec4 a_particle_tilingOffset;\n    uniform vec4 a_particle_flipUV;\n#endif\n\nuniform mat4 u_particle_billboardMatrix;\nuniform vec4 u_particle_pivotOffset;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\nmat3 makeParticleRotationMatrix(vec3 rotation)\n{\n    float DEG2RAD = 3.1415926 / 180.0;\n    \n    float rx = rotation.x * DEG2RAD;\n    float ry = rotation.y * DEG2RAD;\n    float rz = rotation.z * DEG2RAD;\n\n    float sinX = sin(rx);\n    float cosX = cos(rx);\n    float sinY = sin(ry);\n    float cosY = cos(ry);\n    float sinZ = sin(rz);\n    float cosZ = cos(rz);\n\n    mat3 tmp;\n    float ce = cosY * cosZ;\n    float cf = cosY * sinZ;\n    float de = sinY * cosZ;\n    float df = sinY * sinZ;\n\n    float te0 = ce + df * sinX;\n    float te4 = de * sinX - cf;\n    float te8 = cosX * sinY;\n\n    float te1 = cosX * sinZ;\n    float te5 = cosX * cosZ;\n    float te9 = - sinX;\n\n    float te2 = cf * sinX - de;\n    float te6 = df + ce * sinX;\n    float te10 = cosX * cosY;\n\n    tmp[0] = vec3(te0, te1, te2);\n    tmp[1] = vec3(te4, te5, te6);\n    tmp[2] = vec3(te8, te9, te10);\n            \n    return tmp;\n}\n\nvec4 particleAnimation(vec4 position) \n{\n    mat3 billboardMatrix = mat3(u_particle_billboardMatrix[0].xyz,u_particle_billboardMatrix[1].xyz,u_particle_billboardMatrix[2].xyz);\n    \n    position.xyz = position.xyz + u_particle_pivotOffset.xyz;\n    \n    // 计算缩放\n    position.xyz = position.xyz * a_particle_scale.xyz;\n\n    // 计算旋转\n    mat3 rMat = makeParticleRotationMatrix(a_particle_rotation.xyz);\n    position.xyz = rMat * position.xyz;\n    position.xyz = billboardMatrix * position.xyz;\n\n    // 位移\n    position.xyz = position.xyz + a_particle_position.xyz;\n\n    // 颜色\n    v_color = a_particle_color;\n\n    if(a_particle_flipUV.x > 0.5) v_uv.x = 1.0 - v_uv.x;\n    if(a_particle_flipUV.y > 0.5) v_uv.y = 1.0 - v_uv.y;\n    v_uv = v_uv * a_particle_tilingOffset.xy + a_particle_tilingOffset.zw;\n    \n    return position;\n}\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n    //输出uv\n    v_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    position = particleAnimation(position);\n\n    v_uv = v_uv + vec2(_UVSpeedX,_UVSpeedY) * glstate_timer;\n\n    //计算投影坐标\n    position = glstate_matrix_mvp * position;\n\n    #ifdef FOG\n        factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n        factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n    gl_Position = position;\n}","particlesystem_additive.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ]\n  }\n}","particlesystem_additive_transparent_particles_standard.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\n\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\n\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\n    \n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\n    \n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\n    \n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n    \n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\n    \"NOISEUV('NOISEUV', float) = 0.0\",\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\n    \"BlendMode('BlendMode', float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","particlesystem_alphablended.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ]\n  }\n}","particlesystem_alphablended_transparent_particles_standard.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\n\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\n\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\n    \n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\n    \n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\n    \n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n    \n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\n    \"NOISEUV('NOISEUV', float) = 0.0\",\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\n    \"BlendMode('BlendMode', float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem_transparent_particles_standard\",\n        \"fs\": \"particlesystem_transparent_particles_standard\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","particlesystem_transparent_particles_standard.fs.glsl":"precision mediump float;\n\nuniform sampler2D _MainTex;\n\nuniform vec4 u_color;\n\nuniform float EXTENDED_PARTICLES;\nuniform float _EmissionSaturation;\nuniform float _OpacitySaturation;\nuniform float _ColorMultiplier;\n\nuniform float COLOR_RAMP;\nuniform sampler2D _ColorRamp;\nuniform vec4 _ColorRamp_ST;\nuniform float COLOR_TINT;\nuniform vec4 _BasicColor;\nuniform vec4 _SaturatedColor;\n\nuniform float DISSOLVE_ENABLED;\nuniform vec4 _DissolveStep;\n\nuniform float NOISE_TEXTURE;\nuniform sampler2D _NoiseTex;\nuniform vec4 _TintColor;\n\nuniform float EMISSIVEPOWER;\nuniform float _EmissivePower;\n\nuniform float _ABOffset;\n\nuniform float _GlobalAlpha;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvarying vec2 v_particledata;\nvarying vec2 v_noiseuv;\n\nuniform float APPLY_RGB_COLOR_VERTEX;\nuniform float NOISE_TEXTURE_EMISSION;\nuniform float NOISE_TEXTURE_ALPHA;\nuniform float NOISE_TEXTURE_DISSOLVE;\n\nuniform float BlendMode;\n\nvoid main() \n{\n    vec4 tex = texture2D(_MainTex, v_uv);\n\n    vec4 col = vec4(1.0, 1.0, 1.0, 1.0);\n\n    vec4 vcolor = vec4(1.0, 1.0, 1.0, v_color.w);\n\n    if( EXTENDED_PARTICLES > 0.5 )\n    {\n        if( APPLY_RGB_COLOR_VERTEX > 0.5)\n        {\n            vcolor = v_color;\n        }\n\n        float nEmission = 1.0;\n        float nAlpha = 1.0;\n        float nDissolve = 1.0;\n        \n        if( NOISE_TEXTURE > 0.5)\n        {\n            vec3 noise = texture2D(_NoiseTex, v_noiseuv).xyz;\n        \n            if( NOISE_TEXTURE_EMISSION > 0.5)\n            {\n                nEmission = noise.x;\n            }\n            else\n            {\n                nEmission = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_ALPHA > 0.5)\n            {\n                nAlpha = noise.y;\n            }\n            else\n            {\n                nAlpha = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_DISSOLVE > 0.5)\n            {\n                nDissolve = noise.z;\n            }\n            else\n            {\n                nDissolve = 1.0;\n            }\n        }\n    \n        if( DISSOLVE_ENABLED > 0.5)\n        {\n            float ramp = -1.0 + (v_particledata.x * 2.0);\n            col.a = clamp(tex.g * smoothstep(_DissolveStep.x, _DissolveStep.y, (tex.b + ramp) * nDissolve) * _OpacitySaturation * vcolor.w * nAlpha, 0.0, 1.0);\n        }\n        else\n        {\n            col.a = clamp(tex.g * _OpacitySaturation * vcolor.w, 0.0, 1.0) * nAlpha;\n        }\n    \n        float lerpValue = 0.0;\n        if(COLOR_TINT < 0.5)\n        {\n            lerpValue = clamp(tex.r * v_particledata.y * _ColorMultiplier * nEmission, 0.0, 1.0);\n        }\n    \n        if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture2D(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5)\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * _EmissionSaturation;\n                }\n            }\n            col.a *= _GlobalAlpha;\n        }\n        else\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture2D(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * col.a * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5 )\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation * col.a;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * col.a * _EmissionSaturation;\n                }\n            }\n            col *= _GlobalAlpha;\n        }\n    }\n    else\n    {\n        if( 3.5 < BlendMode && BlendMode < 4.5 ) //4\n        {\n            tex *= _TintColor;\n            float luminance = clamp(dot(tex, vec4(0.2126, 0.7152, 0.0722, 0.0)) * tex.a * _ABOffset, 0.0, 1.0);\n            vec4 one = vec4(1, 1, 1, 1);\n            col = mix(2.0 * (v_color * tex), one - 2.0 * (one - v_color) * (one - tex), luminance);\n        }\n        else\n        {\n            col = v_color * tex;\n            col *= _TintColor;\n        \n            if( EMISSIVEPOWER > 0.5)\n            {\n                col *= _EmissivePower;\n            }\n            \n            if( 0.5 < BlendMode && BlendMode < 1.5 ) //1\n            {\n                col.rgb *= col.a;\n            }\n            else\n            {\n                if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n                {\n                    col *= 2.0;\n                }\n                else\n                {\n                    if( 1.5 < BlendMode && BlendMode < 2.5 ) //2\n                    {\n                        col *= 4.0;\n                    }\n                }\n            }\n        }\n    \n        col *= _GlobalAlpha;\n\n    }\n\n    gl_FragColor = col;\n}","particlesystem_transparent_particles_standard.vs.glsl":"\nprecision mediump float;\n\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\nattribute vec4 _glesColor;\n\nuniform vec4 _MainTex_ST;\n\nuniform vec4 _Panning;\nuniform float glstate_timer;\n\nuniform vec4 _NoiseTex_ST;\nuniform vec4 _NoisePanning;\n\nuniform mat4 glstate_matrix_mvp;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nuniform float EXTENDED_PARTICLES;\nvarying vec2 v_particledata;\n\nuniform float NOISE_TEXTURE;\nuniform float NOISEUV;\nvarying vec2 v_noiseuv;\n\n\n\nattribute vec3 a_particle_position;\nattribute vec3 a_particle_scale;\nattribute vec3 a_particle_rotation;\nattribute vec4 a_particle_color;\nattribute vec4 a_particle_tilingOffset;\nattribute vec2 a_particle_flipUV;\n\nuniform mat4 u_particle_billboardMatrix;\n\n\nmat3 makeParticleRotationMatrix(vec3 rotation)\n{\n    float DEG2RAD = 3.1415926 / 180.0;\n    \n    float rx = rotation.x * DEG2RAD;\n    float ry = rotation.y * DEG2RAD;\n    float rz = rotation.z * DEG2RAD;\n\n    float sinX = sin(rx);\n    float cosX = cos(rx);\n    float sinY = sin(ry);\n    float cosY = cos(ry);\n    float sinZ = sin(rz);\n    float cosZ = cos(rz);\n\n    mat3 tmp;\n    float ce = cosY * cosZ;\n    float cf = cosY * sinZ;\n    float de = sinY * cosZ;\n    float df = sinY * sinZ;\n\n    float te0 = ce + df * sinX;\n    float te4 = de * sinX - cf;\n    float te8 = cosX * sinY;\n\n    float te1 = cosX * sinZ;\n    float te5 = cosX * cosZ;\n    float te9 = - sinX;\n\n    float te2 = cf * sinX - de;\n    float te6 = df + ce * sinX;\n    float te10 = cosX * cosY;\n\n    tmp[0] = vec3(te0, te1, te2);\n    tmp[1] = vec3(te4, te5, te6);\n    tmp[2] = vec3(te8, te9, te10);\n            \n    return tmp;\n}\n\nvec4 particleAnimation(vec4 position) \n{\n    mat3 billboardMatrix = mat3(u_particle_billboardMatrix[0].xyz,u_particle_billboardMatrix[1].xyz,u_particle_billboardMatrix[2].xyz);\n    \n    // 计算缩放\n    position.xyz = position.xyz * a_particle_scale.xyz;\n\n    // 计算旋转\n    mat3 rMat = makeParticleRotationMatrix(a_particle_rotation.xyz);\n    position.xyz = rMat * position.xyz;\n    position.xyz = billboardMatrix * position.xyz;\n\n    // 位移\n    position.xyz = position.xyz + a_particle_position.xyz;\n\n    // 颜色\n    v_color = a_particle_color * _glesColor;\n\n    if(a_particle_flipUV.x > 0.5) v_uv.x = 1.0 - v_uv.x;\n    if(a_particle_flipUV.y > 0.5) v_uv.y = 1.0 - v_uv.y;\n    v_uv = v_uv * a_particle_tilingOffset.xy + a_particle_tilingOffset.zw;\n    \n    return position;\n}\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n\n    position = particleAnimation(position);\n    \n    gl_Position = glstate_matrix_mvp * position;\n    v_uv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_Panning.xy * glstate_timer);\n    // v_color = _glesColor;\n    // v_color = vec4(1.0,1.0,1.0,1.0);\n\n    if(EXTENDED_PARTICLES > 0.5)\n    {\n        if( NOISE_TEXTURE > 0.5)\n        {\n            if( NOISEUV > 0.5)\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _NoiseTex_ST.xy + _NoiseTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n            else\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n        }\n    }\n    else\n    {\n        // v_particledata = _glesMultiTexCoord0.zw;\n        v_particledata = _glesMultiTexCoord0;\n    }\n}","particles_add.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"add\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_add_notest.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"add\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"ztest\":\"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_blend.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blend\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_blend_notest.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blend\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"ztest\":\"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_diffuse.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"showface\": \"ccw\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particle_mask_add_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"par_mask_tint\",\n                \"fs\": \"par_mask_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particle_mask_blend_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"par_mask_tint\",\n                \"fs\": \"par_mask_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","par_mask_tint.fs.glsl":"uniform sampler2D _Main_Tex; \nuniform sampler2D _Mask; \n\nvarying mediump vec2 _maintex_uv;\nvarying mediump vec2 _mask_uv;\n\nvarying mediump vec4 v_color;\n\n//texture2DEtC1Mark\n\nvoid main()    \n{\n    highp vec4 basecolor=texture2D(_Main_Tex,_maintex_uv);\n    highp vec4 maskcolor=texture2D(_Mask,_mask_uv);\n\n    mediump vec3 tempcolor=v_color.rgb*basecolor.rgb*maskcolor.rgb;\n    mediump float tempAlpha=v_color.a*basecolor.a*maskcolor.a;\n    mediump vec4 emission=vec4(tempcolor,tempAlpha);\n    \n    gl_FragData[0] = emission;\n}\n","par_mask_tint.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute highp vec4 _glesColor;\nattribute mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _Main_Tex_ST;\nuniform mediump vec4 _Mask_ST;\nvarying mediump vec2 _maintex_uv;\nvarying mediump vec2 _mask_uv;\n\nuniform mediump vec4 _Main_Color;\nuniform mediump float _mixColorRate;\nuniform mediump float _mixAlphaRate;\n\nvarying mediump vec4 v_color;\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\tposition =glstate_matrix_mvp * position;\n\t \n    _maintex_uv = _glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\n\tv_color=_glesColor*_Main_Color;\n\tv_color.rgb=v_color.rgb*_mixColorRate;\n\tv_color.a=v_color.a*_mixAlphaRate;\n\n\tgl_Position = position;\n}","pbr.fs.glsl":"#extension GL_OES_standard_derivatives : enable\n#ifdef TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI          3.141592653589\n#define GAMMA 2.2\n\n// uniform vec4 light_1;\n// uniform vec4 light_2;\n\nuniform float diffuseIntensity;\nuniform float specularIntensity;\nuniform float uvRepeat;\n\nuniform lowp float glstate_lightcount;\n// uniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\n// uniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp vec4 glstate_vec4_lightcolors[8];\n// uniform lowp float glstate_float_lightrange[8];\nuniform lowp float glstate_float_lightintensity[8];\n\nuniform samplerCube u_env;      // IBL\nuniform samplerCube u_diffuse;  // diffuse\nuniform float u_Exposure;\n// uniform sampler2D brdf;       // BRDF LUT\nuniform vec4 glstate_eyepos;\n\n// PBR 材质贴图\nuniform sampler2D uv_Normal;\nuniform sampler2D uv_Basecolor;\nuniform sampler2D uv_MetallicRoughness;\nuniform sampler2D uv_AO;\nuniform sampler2D uv_Emissive;\n\n// Customize value\nuniform vec4 CustomBasecolor;\nuniform float CustomMetallic;\nuniform float CustomRoughness;\n\n#define TEX_FORMAT_METALLIC     rgb\n#define TEX_FORMAT_ROUGHNESS    a\n\nvarying vec3 v_normal;\nvarying vec3 v_pos;\nvarying vec2 xlv_TEXCOORD0;\nvarying mat3 TBN;\n\n#ifdef LIGHTMAP\nuniform lowp float glstate_lightmapRGBAF16;\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\nvec4 sRGBtoLINEAR(vec4 color) {\n    return vec4(pow(color.rgb, vec3(GAMMA)), color.a);\n}\nvec4 LINEARtoSRGB(vec4 color) {\n    return vec4(pow(color.rgb, vec3(1.0 / GAMMA)), color.a);\n}\n\nvec3 toneMapACES(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return pow(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0), vec3(1.0 / GAMMA));\n}\n\nvec2 DFGApprox(float NoV, float roughness) {\n    float dotNV = clamp(NoV, 0., 1.);\n    vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n// Fresnel - F0 = Metalness\nvec3 F_Schlick(float VoH, vec3 F0) {\n    return F0 + (vec3(1) - F0) * pow(1.0 - VoH, 5.0);\n}\n\n// Geometric\n// >    Schlick with k = α/2 matches Smith very closely\nfloat G_UE4(float NoV, float NoH, float VoH, float NoL, float roughness) {\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    float l = NoL / (NoL * (1.0 - k) + k);  // There are another version which use NoH & LoH\n    float v = NoV / (NoV * (1.0 - k) + k);\n    return l * v;\n}\n\n// a (alphaRoughness) = Roughness\n// Distribution AKA normal distribution function (NDF)\n// Trowbridge-Reitz\nfloat D_GGX(float a, float NoH) {\n    a = a * a;\n    // float f = (NoH * a - NoH) * NoH + 1.0;  // NoH * NoH * (a - 1.0) + 1.0;\n    float f = NoH * NoH * (a - 1.0) + 1.0;\n    return a / (PI * f * f);\n}\n\n// mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv){\n//     // get edge vectors of the pixel triangle\n//     vec3 dp1 = dFdx( p );\n//     vec3 dp2 = dFdy( p );\n//     vec2 duv1 = dFdx( uv );\n//     vec2 duv2 = dFdy( uv );\n\n//     // solve the linear system\n//     vec3 dp2perp = cross( dp2, N );\n//     vec3 dp1perp = cross( N, dp1 );\n//     vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n//     vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n//     // construct a scale-invariant frame\n//     float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n//     return mat3( T * invmax, B * invmax, N );\n// }\n\n// decode RGBE data after LOD due to RGB32F mipmap issue\nvec3 decoRGBE(vec4 r) {\n    if(r.a != 0.) {\n        float e = exp2(r.a * 255. - 128.);\n        return vec3(r.r * e, r.g * e, r.b * e);\n    }\n    return vec3(0);\n}\n\nstruct st_core {\n    vec4 diffuse;\n    vec3 f0;\n    vec3 N;\n    vec3 V;\n    vec3 R;\n    float NoV;\n    float metallic;\n    float roughness;\n    float alphaRoughness;\n};\n\nst_core init() {\n    st_core temp;\n\n    // PBR Material\n    temp.diffuse = (sRGBtoLINEAR(texture2D(uv_Basecolor, xlv_TEXCOORD0 * uvRepeat)) * CustomBasecolor);\n\n    vec3 rm = texture2D(uv_MetallicRoughness, xlv_TEXCOORD0 * uvRepeat).rgb;\n    temp.roughness = clamp(rm.g, 0.04, 1.0) * CustomRoughness;\n    temp.alphaRoughness = temp.roughness * temp.roughness;\n    temp.metallic = clamp(rm.b, 0.0, 1.0) * CustomMetallic;\n\n    // vec4 AO = sRGBtoLINEAR(texture2D(uv_AO, xlv_TEXCOORD0 * uvRepeat));\n\n    vec3 f0 = vec3(0.04);\n    temp.f0 = mix(f0, temp.diffuse.xyz, temp.metallic);\n\n    temp.diffuse.rgb = temp.diffuse.rgb * (vec3(1) - f0) * (1. - temp.metallic);\n    // temp.diffuse/=PI;\n\n    temp.V = normalize(glstate_eyepos.xyz - v_pos);\n    // mat3 TBN = cotangent_frame(temp.N, temp.V, xlv_TEXCOORD0 * uvRepeat);\n    vec3 normalAddation = texture2D(uv_Normal, xlv_TEXCOORD0 * uvRepeat).rgb * 2. - 1.;\n    temp.N = normalize(TBN * normalAddation);\n\n    temp.NoV = clamp(abs(dot(temp.N, temp.V)), 0.001, 1.0);\n    temp.R = -normalize(reflect(temp.V, temp.N));\n\n    return temp;\n}\n\nvec3 lightBRDF(vec3 L, st_core core) {\n    L = normalize(L);\n    vec3 H = normalize(core.V + L);\n\n    float NoL = clamp(dot(core.N, L), 0.001, 1.0);\n    float NoH = clamp(dot(core.N, H), 0.0, 1.0);\n    // float LoH = clamp(dot(L, H), 0.0, 1.0);\n    float VoH = clamp(dot(core.V, H), 0.0, 1.0);\n\n    // vec3 diffuse = core.Basecolor.rgb * NoL / PI;\n\n    vec3 F = F_Schlick(VoH, core.f0);\n    float G = G_UE4(core.NoV, NoH, VoH, NoL, core.roughness);\n    float D = D_GGX(core.alphaRoughness, NoH);\n\n    vec3 specContrib = F * G * D / (4.0 * NoL * core.NoV);\n    vec3 diffuseContrib = (1.0 - F) * core.diffuse.rgb / PI;\n    vec3 color = NoL * (diffuseContrib + specContrib);\n\n    return color;\n}\n\nvoid main() {\n    st_core c = init();\n    float lod = clamp(c.roughness * 10.0, 0.0, 11.0);\n    vec3 finalColor;\n\n    // vec2 envBRDF    = texture2D(brdf, vec2(clamp(c.NoV, 0.0, 0.9999999), clamp(1.0-c.Roughness, 0.0, 0.9999999))).rg;\n    int lightCount = int(min(3., glstate_lightcount));\n    if (lightCount > 0) {\n        for (int i = 0; i < 8; i++) {\n            if (i >= lightCount) break;\n            finalColor += lightBRDF(glstate_vec4_lightdirs[i].xyz, c) * glstate_vec4_lightcolors[i].rgb * glstate_float_lightintensity[i];\n        }\n    }\n    // finalColor += lightBRDF(light_1.xyz, c) * vec3(0.6, 0.4, 0.6) * 3.0;\n    // finalColor += lightBRDF(light_2.xyz - v_pos, c) * vec3(0.6, 0.6, 0.4);\n    // finalColor += ((1.0 - F) * (1.0 - c.Metallic) * c.Basecolor.rgb + indirectSpecular) * c.AO.rgb; // IBL+PBR\n\n    // vec3 brdf = sRGBtoLINEAR(texture2D(brdf, clamp(vec2(c.NoV, 1. - c.roughness), vec2(0), vec2(1)))).rgb;\n    vec2 brdf = DFGApprox(c.NoV, c.roughness);\n    #ifdef TEXTURE_LOD\n        vec3 IBLColor = decoRGBE(textureCubeLodEXT(u_env, c.R, lod));\n    #else\n        vec3 IBLColor = decoRGBE(textureCube(u_env, c.R));\n    #endif\n    vec3 IBLspecular = 1.0 * IBLColor * (c.f0 * brdf.x + brdf.y);\n    finalColor += IBLspecular * specularIntensity;\n\n    #ifdef TEXTURE_LOD\n        finalColor += c.diffuse.rgb * decoRGBE(textureCubeLodEXT(u_diffuse, c.R, lod)) * diffuseIntensity;\n    #else\n        finalColor += c.diffuse.rgb * decoRGBE(textureCube(u_diffuse, c.R)) * diffuseIntensity;\n    #endif\n\n#ifdef LIGHTMAP\n    //有lightMap 时，用lightmap 贡献一部分 间接光照\n    vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    vec3 lightMapColor;\n    if(glstate_lightmapRGBAF16 == 1.0){\n        // finalColor.xyz *= lightmap.xyz;\n        lightMapColor = sRGBtoLINEAR(lightmap).rgb;\n    }else{\n        // finalColor.xyz *= decode_hdr(lightmap);\n        lightMapColor = decode_hdr(lightmap);\n    }\n\n    // finalColor += c.diffuse.rgb * lightMapColor;\n    finalColor += c.diffuse.rgb * lightMapColor * diffuseIntensity;;\n#endif\n\n    // finalColor += sRGBtoLINEAR(texture2D(uv_Emissive, xlv_TEXCOORD0 * uvRepeat)).rgb;\n    finalColor *= u_Exposure * texture2D(uv_AO, xlv_TEXCOORD0 * uvRepeat).r;\n\n    finalColor = toneMapACES(finalColor);\n\n#ifdef FOG\n    finalColor.xyz = mix(glstate_fog_color.rgb, finalColor.rgb, factor);\n#endif\n    gl_FragColor = vec4(finalColor, c.diffuse.a);\n}","pbr.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"uv_Basecolor('albedo',Texture)='white'{}\",\n        \"uv_MetallicRoughness('MetallicRoughness',Texture)='white'{}\",\n        \"uv_AO('AO',Texture)='white'{}\",\n        \"uv_Normal('Normal',Texture)='normal'{}\",\n        \"CustomBasecolor ('Color', Color) = (1,1,1,1)\",\n        \"CustomMetallic('Metallic',Range(0.0,1.0)) = 1.0\",\n        \"CustomRoughness('Roughness',Range(0.0,1.0)) = 1.0\",\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"pbr\",\n                \"fs\": \"pbr\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","pbr.vs.glsl":"attribute highp vec3    _glesVertex;\r\nattribute mediump vec2    _glesMultiTexCoord0;\r\nattribute highp vec3    _glesNormal;\r\nattribute highp vec3    _glesTangent;\r\nattribute highp vec3    _glesColor;\r\n\r\nuniform highp mat4      glstate_matrix_mvp;\r\nuniform highp mat4      glstate_matrix_model;\r\nuniform highp mat4      glstate_matrix_it_modelview;\r\n\r\nvarying highp vec3      v_normal;\r\nvarying highp vec3      v_pos;\r\nvarying highp vec2      xlv_TEXCOORD0;\r\nvarying highp mat3\t\tTBN;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec2 _glesMultiTexCoord1;\r\nuniform lowp float glstate_lightmapUV;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    mat4 mat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn mat* srcVertex;\r\n}\r\n#endif\r\n\r\nvoid main () {\r\n    highp vec4 position = vec4(_glesVertex,1.0);\r\n\r\n#ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = (1.0 - glstate_lightmapUV) * _glesMultiTexCoord0  + glstate_lightmapUV * _glesMultiTexCoord1;\t//unity lightMap UV ,优先使用UV1,次之UV0 \r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n#endif\r\n\r\n#ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n#endif\r\n\r\n    vec4 wpos\t\t= (glstate_matrix_model * position);\r\n\tv_pos\t\t\t= wpos.xyz / wpos.w;\r\n    v_normal        = normalize((glstate_matrix_it_modelview * vec4(_glesNormal, 0.0)).xyz);\r\n    xlv_TEXCOORD0   = _glesMultiTexCoord0;\r\n\r\n\t// TBN\r\n\tvec3 tangent = normalize((glstate_matrix_it_modelview * vec4(_glesTangent, 0.0)).xyz);\r\n\tvec3 bitangent = cross(v_normal, tangent);// * _glesTangent.w;\r\n\tTBN = mat3(tangent, bitangent, v_normal);\r\n\r\n\tposition = glstate_matrix_mvp * position;\r\n\r\n#ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n#endif\r\n\r\n    gl_Position\t= position;\r\n}","pbrMR.fs.glsl":"precision mediump  float;\n\n#define PI 3.14159265358979\n#define GAMMA 2.2\n\nuniform lowp sampler2D uv_Basecolor;\nuniform lowp sampler2D uv_Normal;\nuniform sampler2D brdf;\nuniform samplerCube u_sky;// IBL\nuniform samplerCube u_sky_1;// IBL\nuniform samplerCube u_sky_2;// IBL\nuniform samplerCube u_sky_3;// IBL\nuniform samplerCube u_sky_4;// IBL\nuniform lowp vec4 _MainColor;\nuniform vec4 glstate_eyepos;\n\nvarying vec3 v_pos;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying highp vec4 v_color;\n\nvarying vec3 v_normal;\nvarying mat3 TBN;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\n#define fixedAmbient    vec4(1, 1, 1, 1.0)\n#define LIGHT_COLOR     vec4(1)\n#define LIGHT_DIRECTION vec3(0, 1, 0)\n#define DIFFUSE_CTB     dot(normalize(v_normal.xyz), normalize(LIGHT_DIRECTION))\n#define DIFFUSE         (DIFFUSE_CTB * 0.5) * LIGHT_COLOR\n\n#define METALLIC    0.1\n#define ROUGHNESS   0.7\n\n// uniform float ROUGHNESS;\n// uniform float METALLIC;\n\n//texture2DEtC1Mark\n\nvec4 sRGBtoLINEAR(vec4 color) {\n    return vec4(pow(color.rgb, vec3(GAMMA)), color.a);\n}\nvec4 LINEARtoSRGB(vec4 color) {\n    return vec4(pow(color.rgb, vec3(1.0/GAMMA)), color.a);\n}\n\n\n// Fresnel - F0 = Metalness\nvec3 F_Schlick(float VoH, vec3 F0) {\n    return F0 + (vec3(1) - F0) * pow(1.0 - VoH, 5.0);\n}\n// vec3 Fresnel_CookTorrance(float VoH, vec3 F0) {\n// }\nvec3 F_UE4(float VoH, vec3 F0) {\n    return F0 + (vec3(1.0) - F0) * pow(2.0, (-5.55473 * VoH - 6.98316) * VoH);\n}\n\n\n// Geometric\nfloat G_CookTorrance(float NoV, float NoH, float VoH, float NoL) {\n    return min(min(2.0 * NoV * NoH / VoH, 2.0 * NoL * NoH / VoH), 1.0);\n}\n// >    Schlick with k = α/2 matches Smith very closely\nfloat G_UE4(float NoV, float NoH, float VoH, float NoL, float roughness) {\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    float l = NoL / (NoL * (1.0 - k) + k);  // There are another version which use NoH & LoH\n    float v = NoV / (NoV * (1.0 - k) + k);\n    return l * v;\n}\n\n\n// a (alphaRoughness) = Roughness\n// Distribution AKA normal distribution function (NDF)\n// Trowbridge-Reitz\nfloat D_GGX(float a, float NoH) {\n    a = a * a;\n    // float f = (NoH * a - NoH) * NoH + 1.0;  // NoH * NoH * (a - 1.0) + 1.0;\n    float f = NoH * NoH * (a - 1.0) + 1.0;\n    return a / (PI * f * f);\n}\n\nvoid main()\n{\n    //gl_FragData[0] = v_color;\n\n    vec4 base = sRGBtoLINEAR(texture2D(uv_Basecolor, xlv_TEXCOORD0));\n    // vec4 base = sRGBtoLINEAR(vec4(0.8, 0.69, 0.13,1));\n    // if(base.a < 0.1)\n    //     discard;\n\n\n\n    vec4 fristColor = vec4(v_color.rgb, 1);\n    vec3 normalAddation = texture2D(uv_Normal, xlv_TEXCOORD0).rgb * 2.0 - 1.0;\n\n    vec3 L = normalize(LIGHT_DIRECTION);\n    vec3 N = normalize(TBN * normalAddation);\n    // vec3 N = normalize(v_normal);\n    vec3 V = normalize(glstate_eyepos.xyz - v_pos);\n    vec3 H = normalize(V + L);\n    vec3 R = -normalize(reflect(V, N));\n\n    float NoL = clamp(dot(N, L), 0.001, 1.0);\n    float NoV = clamp(abs(dot(N, V)), 0.001, 1.0);\n    float NoH = clamp(dot(N, H), 0.0, 1.0);\n    float LoH = clamp(dot(L, H), 0.0, 1.0);\n    float VoH = clamp(dot(V, H), 0.0, 1.0);\n\n    float roughness = clamp(ROUGHNESS, 0.04, 1.0);\n    float alphaRoughness = roughness * roughness;\n    float metallic = clamp(METALLIC, 0.0, 1.0);\n\n    vec3 f0 = vec3(0.04);\n    f0 = mix(f0, base.rgb, metallic);\n\n    vec3 diffuse = base.rgb * (vec3(1) - f0);\n    diffuse *= 1.0 - metallic;\n    // diffuse /= PI;\n\n    vec3 F = F_Schlick(VoH, f0);\n    float G = G_UE4(NoV, NoH, VoH, NoL, roughness);\n    // float G = G_CookTorrance(NoV, NoH, VoH, NoL);\n    float D = D_GGX(alphaRoughness, NoH);\n\n    vec3 specContrib = F * G * D / (4.0 * NoL * NoV);\n    vec3 diffuseContrib = (1.0 - F) * diffuse * (1.0 - metallic);\n    vec3 color = NoL * LIGHT_COLOR.xyz * (diffuseContrib + specContrib * 10.0);\n    // color += fixedAmbient.rgb * 0.3;\n\n\n    // IBL\n    vec3 brdf = sRGBtoLINEAR(texture2D(brdf, vec2(NoV, 1.0 - alphaRoughness))).rgb;\n    // vec3 IBLcolor = vec3(1);\n    vec3 IBLcolor = vec3(1, 0.6, 0);\n    // vec3 IBLcolor = sRGBtoLINEAR(textureCube(envTex, R)).rgb + vec3(0.5);\n\n    vec3 IBLspecular = 1.0 * IBLcolor * (f0 * brdf.x + brdf.y);\n    color += IBLspecular;\n    color += IBLspecular;\n    color += IBLspecular;\n    color += IBLspecular;\n    // color += IBLspecular;\n    // color += IBLspecular;\n    // color += IBLspecular;\n\n\n    // Diffuse\n    vec4 emission = (fristColor * vec4(color, 1)) + (fristColor * fixedAmbient);\n\n\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    //emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, v_color.a);\n    #endif\n\n    gl_FragData[0] = LINEARtoSRGB(emission);\n    gl_FragData[0] = LINEARtoSRGB(vec4(V, 1));\n    gl_FragData[0] = LINEARtoSRGB(vec4(color, 1));\n    // gl_FragData[0] = LINEARtoSRGB(vec4(IBLspecular * 2.0, 1));\n    // gl_FragData[0] = LINEARtoSRGB(vec4(pow(1.0 - NoV, 5.0)));\n    // gl_FragData[0] = LINEARtoSRGB(vec4(G));\n    // gl_FragData[0] = LINEARtoSRGB(vec4(G));\n    // gl_FragData[0] = LINEARtoSRGB(vec4(D));\n}","pbrMR.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\",\n        \"_NormalTex('NormalTex', Texture) = 'white'{}\",\n        \"OFFSET ('OFFSET', Vector) = (0,0,0,0)\"\n    ],\n    \"passes\": {\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbrMR\",\n                \"fs\": \"pbrMR\"\n            }\n        ],\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"pbrMR\",\n                \"fs\": \"pbrMR\"\n            }\n        ]\n    }\n}","pbrMR.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\n\nuniform mediump vec4 _MainTex_ST;\nvarying mediump vec2 xlv_TEXCOORD0;\n\nattribute lowp vec3 _glesNormal;\nattribute lowp vec3 _glesTangent;\n\nuniform highp mat4      glstate_matrix_mvp;\nuniform highp mat4      glstate_matrix_model;\nuniform highp mat4      glstate_matrix_world2object;\n\nvarying highp vec3 v_N;\nvarying mat3 TBN;\n\n#ifdef FOG\nvarying lowp float factor;\n#endif\n\nuniform highp vec4 OFFSET;\n\nattribute vec4 _glesColor;\nvarying highp vec4 v_color;\n\nvarying vec3 v_pos;\n\n#define DIST\t20.0\n#define FOG_far\t100.0\n\n\nlowp mat3 calBTNMatrix(lowp mat3 NormalMatToWorld,lowp vec3 _normal,lowp vec3 _tangent)\n{\n    lowp vec3 normal=normalize(NormalMatToWorld*_normal);\n    lowp vec3 tangent=normalize(NormalMatToWorld*_tangent);\n    lowp vec3 binormal=cross(normal,tangent);\n  \treturn (mat3(tangent,binormal,normal));\n\n}\n\nvoid main()\n{\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    mat3 normalmat = mat3(glstate_matrix_model);\n   \tTBN=calBTNMatrix(normalmat,_glesNormal,_glesTangent);\n\n\n    v_N = _glesNormal;\n    // // v_N = normalize(glstate_matrix_world2object*vec4(v_N, 1)).xyz;\n    // v_N = normalize(glstate_matrix_model*vec4(v_N, 1)).xyz;\n\n    // vec3 tangent = normalize(vec3(glstate_matrix_model * vec4(_glesTangent.xyz, 0)));\n    // vec3 bitangent = cross(v_N, tangent) * 1.0;\n    // TBN = mat3(tangent, bitangent, v_N);\n\n    position = (glstate_matrix_mvp * position);\n\n\thighp float zOff = position.z / DIST;\n\tposition += OFFSET * zOff * zOff;\n\n    v_pos = (glstate_matrix_model * vec4(_glesVertex.xyz,1.0)).xyz;\n    // v_pos = _glesVertex.xyz;\n\n    #ifdef FOG\n    highp float x = position.z;\n    x = clamp(x,0.0,FOG_far);\n    highp float a = 2.0*FOG_far/x -1.0;\n    factor = 1.0 - 1.0/a;\n    #endif\n\tv_color = _glesColor;\n    gl_Position =position;\n}","pbr_sss.fs.glsl":"#extension GL_OES_standard_derivatives : enable\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI          3.141592653589\n\nuniform vec4        light_1;\nuniform vec4        light_2;\n\nuniform samplerCube u_sky;      // IBL\nuniform samplerCube u_sky_1;    // IBL\nuniform samplerCube u_sky_2;    // IBL\nuniform samplerCube u_sky_3;    // IBL\nuniform samplerCube u_sky_4;    // IBL\n\nuniform sampler2D   brdf;       // BRDF LUT\nuniform vec4        glstate_eyepos;\n\n// PBR 材质贴图\nuniform sampler2D   uv_Normal;\nuniform sampler2D   uv_Basecolor;\nuniform sampler2D   uv_MetallicRoughness;\nuniform sampler2D   uv_AO;\n\n// Customize value\nuniform vec4        CustomBasecolor;\nuniform float       CustomMetallic;\nuniform float       CustomRoughness;\nuniform sampler2D   uv_Thickness;\n\n#define TEX_FORMAT_METALLIC     rgb\n#define TEX_FORMAT_ROUGHNESS    a\n\nvarying vec3        v_normal;\nvarying vec3        v_pos;\nvarying vec2        xlv_TEXCOORD0;\n\n//texture2DEtC1Mark\n\nvec3 Fresnel(vec3 f0, float LoN, float roughness) {\n    return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(1.0 - LoN, 5.0);\n}\n\nfloat Distribution(float roughness, float NoH) {\n    float alpha = roughness * roughness;\n    float alphaSq = alpha * alpha;\n    float NoHsqr = NoH * NoH;\n    return alphaSq / (pow( NoHsqr * alphaSq - NoHsqr + 1.0, 2.0) * PI);;\n}\n\nfloat Geometric(float roughness, float NoL, float NoV) {\n    float k = pow(roughness + 1.0, 2.0) / 8.0;\n    float Gl = NoL / ((NoL - NoL * k) + k);\n    float Gv = NoV / ((NoV - NoV * k) + k);\n    return Gl * Gv;\n}\n\nmat3 cotangent_frame(vec3 N, vec3 p, vec2 uv){\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( p );\n    vec3 dp2 = dFdy( p );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n\n    // solve the linear system\n    vec3 dp2perp = cross( dp2, N );\n    vec3 dp1perp = cross( N, dp1 );\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n    // construct a scale-invariant frame\n    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n    return mat3( T * invmax, B * invmax, N );\n}\n\nvec3 getIBL(float roughness, vec3 r) {\n    float a = roughness * 4.0;\n\n    if ( a < 1.0)   return mix(textureCube(u_sky, r).rgb, textureCube(u_sky_1, r).rgb, a);\n    if ( a < 2.0)   return mix(textureCube(u_sky_1, r).rgb, textureCube(u_sky_2, r).rgb, a - 1.0);\n    if ( a < 3.0)   return mix(textureCube(u_sky_2, r).rgb, textureCube(u_sky_3, r).rgb, a - 2.0);\n    if ( a < 4.0)   return mix(textureCube(u_sky_3, r).rgb, textureCube(u_sky_4, r).rgb, a - 3.0);\n    // if ( a < 5.0)   return mix(textureCube(u_sky_4, r).rgb, textureCube(u_sky_5, r).rgb, a - 4.0);\n\n    return textureCube(u_sky_4,r).xyz;\n}\n\nstruct st_core {\n    vec3    f0;\n    float   Roughness;\n    vec4    Basecolor;\n    vec4    Normal;\n    vec3    Metallic;\n    vec4    AO;\n    vec3    N;\n    vec3    V;\n    vec3    L;\n    vec3    H;\n    vec3    R;\n    float   NdotV;\n    float   NdotL;\n    float   LdotH;\n};\n\nst_core init() {\n    st_core temp;\n\n    // PBR Material\n    temp.Basecolor  = texture2D(uv_Basecolor, xlv_TEXCOORD0) * CustomBasecolor;\n    temp.Normal     = texture2D(uv_Normal, xlv_TEXCOORD0);\n    temp.Metallic   = texture2D(uv_MetallicRoughness, xlv_TEXCOORD0).TEX_FORMAT_METALLIC * 0.01;\n    temp.Roughness  = texture2D(uv_MetallicRoughness, xlv_TEXCOORD0).TEX_FORMAT_ROUGHNESS * 0.5;\n    temp.AO         = texture2D(uv_AO, xlv_TEXCOORD0);\n\n    vec3 f0 = vec3(0.04);\n    temp.f0 = mix(f0, temp.Basecolor.xyz, temp.Metallic);\n\n    temp.V = normalize(glstate_eyepos.xyz - v_pos);\n    temp.N = normalize(v_normal);\n    mat3 TBN = cotangent_frame(temp.N, temp.V, xlv_TEXCOORD0);\n    vec3 normalAddation = temp.Normal.rgb * 2.0 - 1.0;\n    temp.N = normalize(TBN * normalAddation);\n    temp.NdotV = abs(dot(temp.N, temp.V));\n    temp.R = reflect(-temp.V,temp.N);\n\n    return temp;\n}\n\nvec3 lightBRDF(vec3 L, st_core c) {\n    L = normalize(L);\n    vec3 H = normalize(c.V + L);\n\n    float LoH = max(0.0, dot(L, H));\n    float NoH = max(0.0, dot(c.N, H));\n    float NoL = max(0.001, dot(c.N, L));\n    float NoV = max(0.0, c.NdotV);\n    float roughness = clamp(c.Roughness, 0.05, 0.9999999);  // NOTE: in case roughness equal 0\n\n    vec3 diffuse = c.Basecolor.rgb * NoL / PI;\n\n    vec3 F = Fresnel(c.f0, LoH, roughness);\n    float D = Distribution(roughness, NoH);\n    float G = Geometric(roughness, NoL, NoV);\n\n    vec3 specular = D * F * G / (4.0 * NoL * NoV);\n    return max(vec3(0.0), diffuse + specular);\n}\n\nvec3 T(float s) {\n  return vec3(0.233, 0.455, 0.649) * exp(-s * s / 0.0064) +\n         vec3(0.1,   0.336, 0.344) * exp(-s * s / 0.0484) +\n         vec3(0.118, 0.198, 0.0)   * exp(-s * s / 0.187)  +\n         vec3(0.113, 0.007, 0.007) * exp(-s * s / 0.567)  +\n         vec3(0.358, 0.004, 0.0)   * exp(-s * s / 1.99)   +\n         vec3(0.078, 0.0,   0.0)   * exp(-s * s / 7.41);\n}\nvec3 translucency(vec3 l, st_core c) {\n    float thick = 1.0 -texture2D(uv_Thickness, xlv_TEXCOORD0).r;\n    vec3 vLTLight = normalize(l);\n    float fLTDot = pow(max(dot(c.N, -vLTLight), 0.4), 2.0) * 1.0;\n    vec3 fLT = 1.0 * (fLTDot + 0.0) * thick * T(thick);\n    return fLT;\n}\n\nvoid main () {\n    st_core c = init();\n\n    vec3 envLight   = textureCube(u_sky, c.R).xyz;\n    vec2 envBRDF    = texture2D(brdf, vec2(clamp(c.NdotV, 0.0, 0.9999999), clamp(1.0-c.Roughness, 0.0, 0.9999999))).rg;\n\n    vec3 F = Fresnel(c.f0, c.NdotV, c.Roughness);\n    vec3 indirectSpecular = envLight * (F * envBRDF.r + envBRDF.g) * vec3(0.3, 0.4, 0.8);\n\n    vec3 finalColor = vec3(0.0);\n    // finalColor += lightBRDF(vec3(-50.0, 50.0, 80.0), c) * vec3(0.7, 0.5, 0.2);\n    finalColor += lightBRDF(vec3(-10.0, 10.0, -10.0), c) * vec3(1.0, 1.0, 1.0);\n    finalColor += ((1.0 - F) * (1.0 - c.Metallic) * c.Basecolor.rgb + indirectSpecular) * 0.6; // IBL+PBR\n    finalColor += translucency(vec3(-10.0, 10.0, -10.0), c) * vec3(1.0, 1.0, 1.0);\n\n    // gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);\n    // gl_FragColor = texture2D(uv_Basecolor, xlv_TEXCOORD0);\n    gl_FragColor = vec4(finalColor, 1.0);\n}","pbr_sss.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"uv_Basecolor('albedo',Texture)='white'{}\",\n        \"uv_MetallicRoughness('MetallicRoughness',Texture)='white'{}\",\n        \"uv_AO('AO',Texture)='white'{}\",\n        \"uv_Normal('Normal',Texture)='normal'{}\",\n        \"CustomBasecolor ('Color', Color) = (1,1,1,1)\",\n        \"CustomMetallic('Metallic',Range(0.0,1.0)) = 1.0\",\n        \"CustomRoughness('Roughness',Range(0.0,1.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"pbr_sss\",\n                \"fs\": \"pbr_sss\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ],\n        \"skin\": [\n\n        ],\n        \"skin_fog\": [\n\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","pbr_sss.vs.glsl":"attribute highp vec3    _glesVertex;\nattribute highp vec2    _glesMultiTexCoord0;\nattribute highp vec3    _glesNormal;\n\nuniform highp mat4      glstate_matrix_mvp;\nuniform highp mat4      glstate_matrix_model;\nuniform highp mat4      glstate_matrix_world2object;\n\nvarying highp vec3      v_normal;\nvarying highp vec3      v_pos;\nvarying highp vec2      xlv_TEXCOORD0;\n\nvoid main () {\n    v_pos           = (glstate_matrix_model * vec4(_glesVertex, 1.0)).xyz;\n    v_normal        = normalize((glstate_matrix_world2object * vec4(_glesNormal, 0.0)).xyz);\n    xlv_TEXCOORD0   = _glesMultiTexCoord0;\n\n    gl_Position     = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}","post_depth.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH  \nprecision highp float;  \n#else  \nprecision mediump float;  \n#endif \n//varying highp vec3 xlv_Normal;   \n\nconst float PackUpscale = 256. / 255.; \n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( const in float v ) \n{\n    vec2 r = vec2( fract( v * PackFactors.z ), v );\n\tr.y -= r.x * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGToDepth( const in vec2 v ) \n{\n    return dot( v.xy, UnpackFactors.zw );\n}\nvec3 packDepthToRGB( const in float v ) \n{\n    vec3 r = vec3( fract( v * PackFactors.yz ), v );\n\tr.yz -= r.xy * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBToDepth( const in vec3 v ) \n{\n    return dot( v.xyz, UnpackFactors.yzw );\n}\nvoid main() \n{\n    float z = gl_FragCoord.z;// fract(gl_FragCoord.z *256.*256.);\n    // highp vec2 normal =xlv_Normal.xy;\n    gl_FragColor=packDepthToRGBA(z);\n}","post_depth.vs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH  \nprecision highp float;  \n#else  \nprecision mediump float;  \n#endif \nattribute vec4 _glesVertex;    \n//attribute vec3 _glesNormal;\n//uniform highp mat4 glstate_matrix_modelview;\nuniform highp mat4 glstate_matrix_mvp;      \n// varying highp vec3 xlv_Normal;                \n       \nvoid main()                                     \n{        \n    // highp mat3 normalMat=mat3(\n    //     glstate_matrix_mvp[0],\n    //     glstate_matrix_mvp[1],\n    //     glstate_matrix_mvp[2]);\n\n    // xlv_Normal=normalMat * _glesNormal;\n    // xlv_Normal+=1.0;\n    // xlv_Normal*=0.5;\n\n    gl_Position = (glstate_matrix_mvp * _glesVertex);  \n}","quad.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    #ifdef QUAD\n    gl_Position = vec4(_glesVertex.xy*2.0,_glesVertex.z,1.0);\n    #else\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n    #endif\n}","radial_blur.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D _MainTex;\nuniform lowp float _Level;\nuniform lowp float _CenterX;\nuniform lowp float _CenterY;\nvarying highp vec2 xlv_TEXCOORD0;\n//texture2DEtC1Mark\n\nvoid main()\n{\n    lowp vec2 center = vec2(_CenterX, _CenterY);// 这里为什么要加1.0？？？\n    lowp vec2 uv = xlv_TEXCOORD0 - center;\n    lowp vec3 tmp = vec3(0, 0, 0);\n    for (lowp float i = 0.0; i < 100.0; i++)// for循环只能用i与常量比较\n    {\n        if (i >= _Level) break;// 在这里跳出循环\n        tmp += texture2D(_MainTex, uv * (1.0 - 0.002 * i) + center).xyz;\n    }\n    lowp vec4 col = vec4(tmp.xyz / _Level, 1);\n    gl_FragData[0] = col;\n}","radial_blur.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Level('Level',Range(0,100))=20\",\n        \"_CenterX ('CenterX', Range(0.0,1.0))=0.5\",\n        \"_CenterY ('CenterY', Range(0.0,1.0))=0.5\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"radial_blur\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"radial_blur\"\n            }\n        ]\n    }\n}","separate_blur.fs.glsl":"uniform sampler2D _MainTex;\n\nvarying highp vec2 uv;\nvarying highp vec4 uv01;\nvarying highp vec4 uv23;\nvarying highp vec4 uv45;\n\n//texture2DEtC1Mark\n\nvoid main() \n{\n    lowp vec4 color=vec4(0,0,0,0);\n    color+=0.4*texture2D(_MainTex, uv.xy);\n    color+=0.15*texture2D(_MainTex, uv01.xy);\n    color+=0.15*texture2D(_MainTex, uv01.zw);\n    color+=0.10*texture2D(_MainTex, uv23.xy);\n    color+=0.10*texture2D(_MainTex, uv23.zw);\n    color+=0.05*texture2D(_MainTex, uv45.xy);\n    color+=0.05*texture2D(_MainTex, uv45.zw);\n\n    gl_FragData[0] = color;\n}\n","separate_blur.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"sample_offsets('sample_offsets',Vector) = (0,1.0,0,-1.0)\",\n        \"_MainTex_TexelSize('MainTex_TexelSize',Vector) = (0.009765,0.009765,1024,1024)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"separate_blur\",\n                \"fs\": \"separate_blur\"\n            }\n        ]\n    }\n}","separate_blur.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\n\nuniform highp vec4 _MainTex_TexelSize;\nuniform highp vec4 sample_offsets;//采样偏移\n\nvarying highp vec2 uv;\nvarying highp vec4 uv01;\nvarying highp vec4 uv23;\nvarying highp vec4 uv45;\n\n\nvoid main()\n{\n    highp vec4 offset=sample_offsets*_MainTex_TexelSize.xyxy;\n\n    uv =vec2(_glesMultiTexCoord0.x,_glesMultiTexCoord0.y);\n\n    uv01=uv.xyxy+offset.xyxy*vec4(1,1,-1,-1);\n    uv23=uv.xyxy+offset.xyxy*vec4(1,1,-1,-1)*2.0;\n    uv45=uv.xyxy+offset.xyxy*vec4(1,1,-1,-1)*3.0;\n\n    gl_Position = vec4(_glesVertex.xy*2.0,_glesVertex.z,1.0);\n}","shadowmap.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH  \nprecision highp float;  \n#else  \nprecision mediump float;  \n#endif \n\nuniform sampler2D _MainTex;\nuniform sampler2D _Light_Depth;\n\nuniform float _AlphaCut;\nuniform float _bias;//这个是根据视角算的。这里先偷个懒，外部传个固定值进来\n\nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec4 _WorldPos;\n\n\nconst float UnpackDownscale = 255. / 256.; \nconst vec3 PackFactors = vec3(256. * 256. * 256., 256. * 256.,  256.);\nconst vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.);\n\n//texture2DEtC1Mark\n\n\nfloat unpackRGBAToDepth(const in vec4 v) \n{\n    return dot(v, UnpackFactors);\n}\n\nvoid main() \n{\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\n\n\tfloat shadowDepth = unpackRGBAToDepth(texture2D(_Light_Depth, _WorldPos.xy));\n    float worldDepth = (_WorldPos.z +1.)/2.;//不理解这里为啥要做变换。\n\n    float _depth = step(shadowDepth + _bias,worldDepth);\n    lowp vec4 temvar_4 = vec4(0.5,0.5,0.5,0) * _depth;\n\n    gl_FragData[0] = tmpvar_3 - temvar_4;\n}","shadowmap.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"shadowmap\",\n                \"fs\": \"shadowmap\",\n                \"zwrite\": \"on\",\n                \"ztest\": \"lequal\"\n            }\n        ],\n        \"base_depth\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"post_depth\",\n                \"fs\": \"post_depth\"\n            }\n        ]\n    }\n}","shadowmap.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4  _LightProjection;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 _MainTex_ST;  \n\nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec4 _WorldPos;\n\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n\t_WorldPos = (_LightProjection * glstate_matrix_model * tmpvar_1);\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}","simple.fs.glsl":"precision highp float;\n\nuniform sampler2D _MainTex;\nuniform float _AlphaCut;\nuniform vec4 _MainColor;\n\nvarying vec2 xlv_TEXCOORD0;    \n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\nvoid main() \n{\n    vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\n\n    if(basecolor.a < _AlphaCut)\n        discard;\n\n    basecolor = basecolor * _MainColor;\n\n    #ifdef FOG\n    basecolor.xyz = mix(glstate_fog_color.rgb, basecolor.rgb, factor);\n    #endif\n        \n    gl_FragData[0] = basecolor;\n}","simple.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.1\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"simple\",\n                \"fs\": \"simple\"\n            }\n        ]\n    }\n}","simple.vs.glsl":"precision highp float;\n\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\nuniform vec4 _MainTex_ST;\n\nvarying lowp vec2 xlv_TEXCOORD0;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n    vec4 position = vec4(_glesVertex.xyz,1.0);\n\n    position = glstate_matrix_mvp * position;\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n    \n    gl_Position = position;\n}","skybox.fs.glsl":"#extension GL_OES_standard_derivatives : enable\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI          3.141592653589\n\nuniform samplerCube u_sky;\nuniform vec4        glstate_eyepos;\nuniform float       u_Exposure;\n\nvarying vec3        v_pos;\n\nvec3 decoRGBE(vec4 r) {\n    if(r.a != 0.) {\n        float e = exp2(r.a * 255. - 128.);\n        return vec3(r.r * e, r.g * e, r.b * e);\n    }\n    return vec3(0);\n}\n\nvec3 toneMapACES(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return pow(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0), vec3(1.0 / 2.2));\n}\n\nvoid main () {\n    gl_FragColor = vec4(toneMapACES(u_Exposure * decoRGBE(textureCube(u_sky, normalize(v_pos - glstate_eyepos.xyz)))), 1);\n}","skybox.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"u_Exposure('Exposure',Range(0.0,100.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"skybox\",\n                \"fs\": \"skybox\"\n            }\n        ],\n        \"base_fog\": [\n\n        ],\n        \"skin\": [\n\n        ],\n        \"skin_fog\": [\n\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","skybox.vs.glsl":"attribute highp vec3    _glesVertex;\n\nuniform highp mat4      glstate_matrix_mvp;\nuniform highp mat4      glstate_matrix_model;\n\nvarying highp vec3      v_pos;\n\nvoid main () {\n    v_pos           = (glstate_matrix_model * vec4(_glesVertex, 1.0)).xyz;\n\n    gl_Position     = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}","sssss.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D       _MainTex;//清晰图\nuniform sampler2D       _DepthTex;//清晰图\nuniform highp vec4      _MainTex_TexelSize;\n\nuniform highp vec4      _BlurDirection;\nuniform highp vec4      _BlurOptions;\n#define BLUR_WIDTH      _BlurOptions.a\n#define BLUR_W_RGB      _BlurOptions.rgb\n#define BLUR_W_RGBA     vec4(_BlurOptions.rgb, 1.0)\n\nvarying highp vec2      xlv_TEXCOORD0;   // 每个片元的纹素坐标\n\n#define DEPTH_CORRECTION 10000.\n\nconst float PackUpscale = 256. / 255.;\n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.;\n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\n//texture2DEtC1Mark\n\nfloat unpackRGBAToDepth( const in vec4 v )\n{\n    return dot( v, UnpackFactors );\n}\n\nvec4 blur(vec2 _step) {\n    float w[6];\n    w[0] = 0.006;\n    w[1] = 0.061;\n    w[2] = 0.242;\n    w[3] = 0.242;\n    w[4] = 0.061;\n    w[5] = 0.006;\n\n    float o[6];\n    o[0] = -1.0;\n    o[1] = -0.6667;\n    o[2] = -0.3333;\n    o[3] = 0.3333;\n    o[4] = 0.6667;\n    o[5] = 1.0;\n    // Fetch color and depth for current pixel\n    vec4 curColor = texture2D(_MainTex, xlv_TEXCOORD0);\n    float curDepth = unpackRGBAToDepth(texture2D(_DepthTex, xlv_TEXCOORD0));\n    vec4 blur = curColor;\n    blur.rgb *= 0.382;\n    vec2 finalStep = curColor.a * _step;\n\n    for(int i = 0; i < 6; i++) {\n        vec2 offset = xlv_TEXCOORD0 + o[i] * finalStep;\n        vec3 color = texture2D(_MainTex, offset).rgb;\n        float depth = unpackRGBAToDepth(texture2D(_DepthTex, offset));\n\n        // if the difference in depth is huge, we mix color back to center color:\n        float s = min(abs(curDepth - depth) * DEPTH_CORRECTION, 1.0);\n        // if(abs(curDepth - depth) > 0.00001) // DEBUG\n        //     return vec4(1.0, 1.0, 1.0, 1.0);\n        color = mix(color, curColor.rgb, s);\n\n        blur.rgb += w[i] * color;\n    }\n    return blur;\n\n}\n\n\nvoid main () {\n    vec4 color = texture2D(_MainTex, xlv_TEXCOORD0);\n    vec4 cblur = blur(_MainTex_TexelSize.xy * _BlurDirection.xy * BLUR_WIDTH * 1.);\n    gl_FragColor = color + cblur * BLUR_W_RGBA;\n\n}\n","sssss.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"sssss\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"sssss\"\n            }\n        ]\n    }\n}","sssss.vs.glsl":"attribute highp vec3    _glesVertex;\nattribute highp vec2    _glesMultiTexCoord0;\nattribute highp vec3    _glesNormal;\n\nuniform highp mat4      glstate_matrix_mvp;\nuniform highp mat4      glstate_matrix_model;\nuniform highp mat4      glstate_matrix_world2object;\n\nvarying highp vec2      xlv_TEXCOORD0;\n\nvoid main () {\n    v_pos           = (glstate_matrix_model * vec4(_glesVertex, 1.0)).xyz;\n    v_normal        = normalize((glstate_matrix_world2object * vec4(_glesNormal, 0.0)).xyz);\n    xlv_TEXCOORD0   = _glesMultiTexCoord0;\n\n    gl_Position     = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}","streamlight.fs.glsl":"uniform lowp sampler2D _MainTex;\nuniform lowp sampler2D _LightTex;\nuniform lowp vec4 _LightColor;\nuniform lowp float _LightRate;\nuniform lowp sampler2D _MaskTex;\nuniform lowp float _AlphaCut;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying mediump vec2 _StreamLightUV;\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//texture2DEtC1Mark\n\nvoid main() \n{\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(emission.a < _AlphaCut)\n        discard;\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n\n    lowp vec4 light = texture2D(_LightTex, _StreamLightUV) * _LightColor * _LightRate;\n    lowp vec4 mask = texture2D(_MaskTex, xlv_TEXCOORD0);\n    light = min(light,mask);\n\n    emission.rgb += light.rgb;\n    gl_FragData[0] = emission;\n}","streamlight.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_LightTex('Light',Texture) = 'black' {}\",\n        \"_LightColor('LightColor',Color) = (1,1,1,1)\",\n        \"_LightRate('LightRate',Range(0.0,1.0)) = 1.0\",\n\t\t\"_SpeedU('SpeedU',float) = 0.5\",\n\t\t\"_SpeedV('SpeedV',float) = 0.5\",\n\t\t\"_MaskTex('Mask',Texture) = 'white' {}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ]\n    }\n}","streamlight.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform lowp float _SpeedU;\nuniform lowp float _SpeedV;\nuniform lowp float glstate_timer;\nuniform mediump vec4 _LightTex_ST;\nuniform mediump vec4 _MainTex_ST;\n\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying mediump vec2 _StreamLightUV;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n    lowp vec2 _speed= vec2(_SpeedU,_SpeedV);\n    _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;\n\n    gl_Position =position;\n}","streamlight_bothside.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_LightTex('Light',Texture) = 'black' {}\",\n        \"_LightColor('LightColor',Color) = (1,1,1,1)\",\n        \"_LightRate('LightRate',Range(0.0,1.0)) = 1.0\",\n\t\t\"_SpeedU('SpeedU',float) = 0.5\",\n\t\t\"_SpeedV('SpeedV',float) = 0.5\",\n\t\t\"_MaskTex('Mask',Texture) = 'white' {}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"streamlight\",\n                \"fs\": \"streamlight\"\n            }   \n        ]\n    }\n}","terrain.fs.glsl":"uniform lowp sampler2D _Splat0;\nuniform lowp sampler2D _Splat1;\nuniform lowp sampler2D _Splat2;\nuniform lowp sampler2D _Splat3;\nuniform lowp sampler2D _Control;\n\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying lowp vec2 uv_Splat0;\nvarying lowp vec2 uv_Splat1;\nvarying lowp vec2 uv_Splat2;\nvarying lowp vec2 uv_Splat3;\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//texture2DEtC1Mark\n\nvoid main() \n{\n    lowp vec4 control = texture2D(_Control, xlv_TEXCOORD0);\n    lowp vec3 lay1 = texture2D(_Splat0,uv_Splat0).xyz;\n    lowp vec3 lay2 = texture2D(_Splat1,uv_Splat1).xyz;\n    lowp vec3 lay3 = texture2D(_Splat2,uv_Splat2).xyz;\n    lowp vec3 lay4 = texture2D(_Splat3,uv_Splat3).xyz;\n    lowp vec4 emission = vec4(lay1*control.r + lay2*control.g + lay3*control.b + lay4*(control.a),1.0);\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n\n    gl_FragData[0] = emission;\n}","terrain.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_Splat0('Layer 1',Texture) = 'white'{}\",\n        \"_Splat1('layer 2',Texture) = 'white'{}\",\n        \"_Splat2('layer 3',Texture) = 'white'{}\",\n        \"_Splat3('layer 4',Texture) = 'white'{}\",\n        \"_Control('Control (RGBA)',Texture) = 'white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"terrain\",\n                \"fs\": \"terrain\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"terrain\",\n                \"fs\": \"terrain\"\n            }\n        ],\n\t\t\"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"terrain\",\n                \"fs\": \"terrain\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"terrain\",\n                \"fs\": \"terrain\"\n            }\n        ]\n    }\n}","terrain.vs.glsl":"attribute vec4 _glesVertex;\nattribute lowp vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform lowp vec4 _Splat0_ST;\nuniform lowp vec4 _Splat1_ST;\nuniform lowp vec4 _Splat2_ST;\nuniform lowp vec4 _Splat3_ST;\n\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying lowp vec2 uv_Splat0;\nvarying lowp vec2 uv_Splat1;\nvarying lowp vec2 uv_Splat2;\nvarying lowp vec2 uv_Splat3;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    uv_Splat0 = _glesMultiTexCoord0.xy * _Splat0_ST.xy + _Splat0_ST.zw;\n    uv_Splat1 = _glesMultiTexCoord0.xy * _Splat1_ST.xy + _Splat1_ST.zw;\n    uv_Splat2 = _glesMultiTexCoord0.xy * _Splat2_ST.xy + _Splat2_ST.zw;\n    uv_Splat3 = _glesMultiTexCoord0.xy * _Splat3_ST.xy + _Splat3_ST.zw;\n    \n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start); \n    factor = clamp(factor, 0.0, 1.0);  \n    #endif\n\n    gl_Position = position;\n}","testtexuv.fs.glsl":"uniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() \n{\n    lowp vec3 tmpvar_3 = vec3(xlv_TEXCOORD0.y);\n    gl_FragData[0] = vec4(tmpvar_3,1.0);\n}","testtexuv.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"testtexuv\",\n                \"fs\": \"testtexuv\",\n                \"zwrite\":\"on\",\n                \"ztest\":\"lequal\"\n            }\n        ]\n    }\n}","testtexuv.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n\txlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}","transparent.fs.glsl":"uniform lowp sampler2D _MainTex;                                                                                                \nvarying highp vec2 xlv_TEXCOORD0;\nuniform lowp float _Alpha;\nuniform lowp float _Superimposition;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//texture2DEtC1Mark\n\nvoid main() \n{\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\n    emission.a=emission.a*_Alpha;\n    emission.xyz *= _Superimposition;\n    //----------------------------------------------------------\n    #ifdef FOG\n    emission.xyz= mix(glstate_fog_color.xyz, emission.xyz, factor);\n    #endif\n    gl_FragData[0] = emission;\n\n}","transparent.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","transparent.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n\nvarying mediump vec2 xlv_TEXCOORD0;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    //----------------------------------------------------------\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n    gl_Position = position;\n}","transparent_particles_standard.fs.glsl":"precision mediump float;\n\nuniform sampler2D _MainTex;\n\nuniform vec4 u_color;\n\nuniform float EXTENDED_PARTICLES;\nuniform float _EmissionSaturation;\nuniform float _OpacitySaturation;\nuniform float _ColorMultiplier;\n\nuniform float COLOR_RAMP;\nuniform sampler2D _ColorRamp;\nuniform vec4 _ColorRamp_ST;\nuniform float COLOR_TINT;\nuniform vec4 _BasicColor;\nuniform vec4 _SaturatedColor;\n\nuniform float DISSOLVE_ENABLED;\nuniform vec4 _DissolveStep;\n\nuniform float NOISE_TEXTURE;\nuniform sampler2D _NoiseTex;\nuniform vec4 _TintColor;\n\nuniform float EMISSIVEPOWER;\nuniform float _EmissivePower;\n\nuniform float _ABOffset;\n\nuniform float _GlobalAlpha;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvarying vec2 v_particledata;\nvarying vec2 v_noiseuv;\n\nuniform float APPLY_RGB_COLOR_VERTEX;\nuniform float NOISE_TEXTURE_EMISSION;\nuniform float NOISE_TEXTURE_ALPHA;\nuniform float NOISE_TEXTURE_DISSOLVE;\n\nuniform float BlendMode;\n\nvoid main() \n{\n    vec4 tex = texture2D(_MainTex, v_uv);\n\n    vec4 col = vec4(1.0, 1.0, 1.0, 1.0);\n\n    vec4 vcolor = vec4(1.0, 1.0, 1.0, v_color.w);\n\n    if( EXTENDED_PARTICLES > 0.5 )\n    {\n        if( APPLY_RGB_COLOR_VERTEX > 0.5)\n        {\n            vcolor = v_color;\n        }\n\n        float nEmission = 1.0;\n        float nAlpha = 1.0;\n        float nDissolve = 1.0;\n        \n        if( NOISE_TEXTURE > 0.5)\n        {\n            vec3 noise = texture2D(_NoiseTex, v_noiseuv).xyz;\n        \n            if( NOISE_TEXTURE_EMISSION > 0.5)\n            {\n                nEmission = noise.x;\n            }\n            else\n            {\n                nEmission = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_ALPHA > 0.5)\n            {\n                nAlpha = noise.y;\n            }\n            else\n            {\n                nAlpha = 1.0;\n            }\n            \n            if( NOISE_TEXTURE_DISSOLVE > 0.5)\n            {\n                nDissolve = noise.z;\n            }\n            else\n            {\n                nDissolve = 1.0;\n            }\n        }\n    \n        if( DISSOLVE_ENABLED > 0.5)\n        {\n            float ramp = -1.0 + (v_particledata.x * 2.0);\n            col.a = clamp(tex.g * smoothstep(_DissolveStep.x, _DissolveStep.y, (tex.b + ramp) * nDissolve) * _OpacitySaturation * vcolor.w * nAlpha, 0.0, 1.0);\n        }\n        else\n        {\n            col.a = clamp(tex.g * _OpacitySaturation * vcolor.w, 0.0, 1.0) * nAlpha;\n        }\n    \n        float lerpValue = 0.0;\n        if(COLOR_TINT < 0.5)\n        {\n            lerpValue = clamp(tex.r * v_particledata.y * _ColorMultiplier * nEmission, 0.0, 1.0);\n        }\n    \n        if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture2D(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5)\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * _EmissionSaturation;\n                }\n            }\n            col.a *= _GlobalAlpha;\n        }\n        else\n        {\n            if( COLOR_RAMP > 0.5)\n            {\n                col.xyz = texture2D(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * col.a * _EmissionSaturation;\n            }\n            else\n            {\n                if( COLOR_TINT > 0.5 )\n                {\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation * col.a;\n                }\n                else\n                {\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * col.a * _EmissionSaturation;\n                }\n            }\n            col *= _GlobalAlpha;\n        }\n    }\n    else\n    {\n        if( 3.5 < BlendMode && BlendMode < 4.5 ) //4\n        {\n            tex *= _TintColor;\n            float luminance = clamp(dot(tex, vec4(0.2126, 0.7152, 0.0722, 0.0)) * tex.a * _ABOffset, 0.0, 1.0);\n            vec4 one = vec4(1, 1, 1, 1);\n            col = mix(2.0 * (v_color * tex), one - 2.0 * (one - v_color) * (one - tex), luminance);\n        }\n        else\n        {\n            col = v_color * tex;\n            col *= _TintColor;\n        \n            if( EMISSIVEPOWER > 0.5)\n            {\n                col *= _EmissivePower;\n            }\n            \n            if( 0.5 < BlendMode && BlendMode < 1.5 ) //1\n            {\n                col.rgb *= col.a;\n            }\n            else\n            {\n                if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\n                {\n                    col *= 2.0;\n                }\n                else\n                {\n                    if( 1.5 < BlendMode && BlendMode < 2.5 ) //2\n                    {\n                        col *= 4.0;\n                    }\n                }\n            }\n        }\n    \n        col *= _GlobalAlpha;\n\n    }\n\n    gl_FragColor = col;\n}","transparent_particles_standard.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\n\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\n\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\n    \n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\n    \n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\n    \n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\n    \n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\n    \"NOISEUV('NOISEUV', float) = 0.0\",\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\n    \"BlendMode('BlendMode', float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"transparent_particles_standard\",\n        \"fs\": \"transparent_particles_standard\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"transparent_particles_standard\",\n        \"fs\": \"transparent_particles_standard\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","transparent_particles_standard.vs.glsl":"\nprecision mediump float;\n\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\nattribute vec4 _glesColor;\n\nuniform vec4 _MainTex_ST;\n\nuniform vec4 _Panning;\nuniform float glstate_timer;\n\nuniform vec4 _NoiseTex_ST;\nuniform vec4 _NoisePanning;\n\nuniform mat4 glstate_matrix_mvp;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nuniform float EXTENDED_PARTICLES;\nvarying vec2 v_particledata;\n\nuniform float NOISE_TEXTURE;\nuniform float NOISEUV;\nvarying vec2 v_noiseuv;\n\nvoid main() \n{\n    vec3 position = _glesVertex;\n    gl_Position = glstate_matrix_mvp * vec4(position, 1.0);\n    v_uv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_Panning.xy * glstate_timer);\n    v_color = _glesColor;\n    // v_color = vec4(1.0,1.0,1.0,1.0);\n\n    if(EXTENDED_PARTICLES > 0.5)\n    {\n        if( NOISE_TEXTURE > 0.5)\n        {\n            if( NOISEUV > 0.5)\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _NoiseTex_ST.xy + _NoiseTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n            else\n            {\n                v_noiseuv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_NoisePanning.xy * glstate_timer);\n            }\n        }\n    }\n    else\n    {\n        // v_particledata = _glesMultiTexCoord0.zw;\n        v_particledata = _glesMultiTexCoord0;\n    }\n}","vignetting.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D       _MainTex;//清晰图\nuniform sampler2D       _BlurTex;//模糊高光的图\nuniform highp vec4      _MainTex_TexelSize;\n\nuniform highp float     _Vignetting;\nuniform highp float     _Blurred_Corners;\nuniform highp float     _Blur_Distance;\nuniform highp float     _Chromatic_Aberration;\n\nvarying highp vec2      xlv_TEXCOORD0;   // 每个片元的纹素坐标\n\n//texture2DEtC1Mark\n\n\nvec2 adjustUV(vec2 uv) {\n    if(uv.x > 1.0) {\n        uv.x = 2.0 - uv.x;\n    } else if(uv.x < 0.0) {\n        uv.x = abs(uv.x);\n    }\n    if(uv.y > 1.0) {\n        uv.y = 2.0 - uv.y;\n    } else if(uv.y < 0.0) {\n        uv.y = abs(uv.y);\n    }\n    return uv;\n}\n\nvoid main () {\n    float dist = distance(xlv_TEXCOORD0, vec2(0.5));\n    // NOTE Unity Parameters:\n    float Vignetting;\n    if(_Vignetting > 0.0) {\n        Vignetting = min(dist/(1.0-_Vignetting), 1.0);\n    } else {\n        Vignetting = _Vignetting;\n    }\n    float Blurred_Corners = min(dist * _Blurred_Corners, 1.0);\n    // vec2 Blur_Distance = vec2(Blur_Distance);\n    float Chromatic_Aberration = _Chromatic_Aberration;\n\n    vec2 direction = xlv_TEXCOORD0 - 0.5;\n\n// offset\n    vec2 r_uv = adjustUV(xlv_TEXCOORD0 - direction * direction * 0.01 * Chromatic_Aberration);\n    vec2 b_uv = adjustUV(xlv_TEXCOORD0 + direction * direction * 0.01 * Chromatic_Aberration);\n\n    float base_r = texture2D(_MainTex, r_uv).r;\n    float base_b = texture2D(_MainTex, b_uv).b;\n\n    vec4 base_color = texture2D(_MainTex, xlv_TEXCOORD0);\n\n    float blur_r = texture2D(_BlurTex, r_uv).r;\n    float blur_b = texture2D(_BlurTex, b_uv).b;\n\n    vec4 blur_color = texture2D(_BlurTex, xlv_TEXCOORD0);\n\n    float ch_r = mix(base_r, blur_r, Blurred_Corners);\n    float ch_b = mix(base_b, blur_b, Blurred_Corners);\n\n    vec4 color = mix(base_color, blur_color, Blurred_Corners);\n\n    vec4 aberration = vec4(ch_r, color.g, ch_b, 1.0);\n    vec4 dark = vec4(0.0, 0.0, 0.0, 1.0);\n\n    gl_FragColor = mix(aberration, dark, Vignetting);\n    // gl_FragColor = vec4(vec3(Blurred_Corners), 1.0);\n\n}\n","vignetting.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_bloomFactor('bloomFactor',Range(0.0,1.0)) = 2.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"vignetting\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"vignetting\"\n            }\n        ]\n    }\n}"}